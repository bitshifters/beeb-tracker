\ ******************************************************************
\\ Beeb Tracker 
\ ******************************************************************




\ ******************************************************************
\ *	Menu state routines
\ ******************************************************************

.init_menu
{
	\\ Copy menu overlay to screen - 8x lines from line 14
	LDX #0
	.loop
	LDA MENU_overlay_src_addr, X
	STA MENU_overlay_dst_addr, X
	INX
	BNE loop

	LDX #(MENU_overlay_size - 1) - &100
	.loop2
	LDA MENU_overlay_src_addr + &100, X
	STA MENU_overlay_dst_addr + &100, X
	DEX
	BPL loop2

	\\ Remember stuff
	LDA file_no
	STA menu_old_file

	.return
	RTS
}

.menu_populate
{
	\\ Populate our menu with entries based on file_no
	LDA file_no
	SEC
	SBC #1
	TAX

	LDY #MENU_top_line_ypos

	.loop
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	TXA:PHA
	BPL positive

	.clamp
	\\ Write blank line
	LDX #MENU_entry_xpos:LDA #MENU_entry_xpos + MENU_entry_width
	JSR teletexel_erase_row
	JMP next

	.positive
	IF COMPILE_OPTION_EXIT
	CPX #NUM_vgm_files+1			; include quit option
	ELSE
	CPX #NUM_vgm_files				; don't include quit option
	ENDIF
	BCS clamp
	
	\\ Write entry from loading_table
	LDA #0:STA write_loop+2

	TXA
	ASL A
	ROL write_loop+2
	ASL A
	ROL write_loop+2
	ASL A
	ROL write_loop+2
	ASL A
	ROL write_loop+2
	ASL A
	ROL write_loop+2				; 16-bit multiply by 32

	; carry is zero
	ADC #LO(menu_entries)
	STA write_loop+1

	LDA #HI(menu_entries)
	ADC write_loop+2
	STA write_loop+2

	\\ Store Y
	TYA:PHA

	LDX #0
	LDY #MENU_entry_xpos
	.write_loop
	LDA menu_entries,X
	STA (writeptr),Y
	INY
	INX
	CPX #MENU_entry_width
	BNE write_loop

	PLA:TAY

	.next
	PLA:TAX
	INX

	INY
	CPY #TRACKER_dupe_line_ypos
	BNE not_dupe
	INY
	.not_dupe
	CPY #MENU_bottom_line_ypos + 1
	BNE loop

	\\ Duplicate line 17 to line 18 for double height
	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_dupe_line_ypos
	JSR mode7_copy_line

	.return
	RTS
}

.deinit_menu
{
	\\ Copy original tracker back to screen - 8x lines from line 14
	LDX #0
	.loop
	LDA MENU_original_src_addr, X
	STA MENU_overlay_dst_addr, X
	INX
	BNE loop

	LDX #(MENU_overlay_size - 1) - &100
	.loop2
	LDA MENU_original_src_addr + &100, X
	STA MENU_overlay_dst_addr + &100, X
	DEX
	BPL loop2

	.return
	RTS
}


\ ******************************************************************
\ *	Demo state routines
\ ******************************************************************

.init_demo
{
	\\ Set load and store addresses
	\\ Is it really necessary to use self-modifying code here?!

	LDA #LO(mode7_screen_data)
	STA loop+1
	LDA #HI(mode7_screen_data)
	STA loop+2

	LDA #LO(MODE7_base_addr)
	STA loop+4
	LDA #HI(MODE7_base_addr)
	STA loop+5

	\\ Initialise MODE 7 screen
	LDY #0
	.loop
	LDA mode7_screen_data,Y				; **SELF-MODIFIED CODE**
	STA MODE7_base_addr,Y				; **SELF-MODIFIED CODE**

	INY
	BNE loop
	INC loop + 2						; increment read address hi byte
	INC loop + 5						; increment write address hi byte
	BPL loop							; until >= &8000			; this is actually overcopying the data as we only have 1000 bytes...

	\\ Initialise our effects
	JSR init_fx

	LDA #LO(demo_message): LDX #HI(demo_message)
	LDY #23: JSR init_scr				; top of scroller at Y

	\\ Initialise music player - pass in VGM_stream_data address
	\\ parses header from stream
; VGM_end_of_data needs to point to the address just after the address
; of the last byte of crunched data.
	LDX #LO(VGM_stream_data - 1)
	LDY #HI(VGM_stream_data - 1)
	JSR	init_vgm_stream

	\\ Copy meta data to screen
	LDX #0
	.meta_loop
	LDA player_song_title,X
	STA META_title_addr,X
	LDA player_song_author,X
	STA META_author_addr,X
	INX
	CPX #META_max_width
	BNE meta_loop

	\\ Copy clock to screen
	LDA #LO(META_clock_addr)
	STA writeptr
	LDA #HI(META_clock_addr)
	STA writeptr+1

	LDX meta_clock_mins
	LDY meta_clock_secs
	JSR write_clock_at_writeptr

	\\ Copy duration to screen
	LDA #LO(META_duration_addr)
	STA writeptr
	LDA #HI(META_duration_addr)
	STA writeptr+1

	LDX player_duration_mins
	LDY player_duration_secs
	JSR write_clock_at_writeptr
	
	\\ Setup the playtime bar
	LDA player_packet_count
	STA playtime_interval
	LDA player_packet_count+1
	STA playtime_interval+1
	LDA #FX_playtime_width
	STA playtime_index

	\\ Divide total packet count by FX_playtime_width using 16bit/8bit math = 16bit result
	LDX #16
	LDA #0
	.div_loop
	ASL playtime_interval
	ROL playtime_interval+1
	ROL A
	CMP playtime_index
	BCC no_sub
	SBC playtime_index
	INC playtime_interval
	.no_sub
	DEX
	BNE div_loop
	
	\\ A contains remainder but we discard as we dont need accuracy
	\\ playtime_interval now contains # of 50Hz updates before playtime_index should be incremented
	LDA #0
	STA playtime_index
	STA playtime_counter
	STA playtime_counter+1

	\\ Hook up Event vector - starts player
	ldx #LO(demo_eventv)
	ldy #HI(demo_eventv)
	JSR start_eventv

	.return
	RTS
}

.poll_demo
{
	\\ Poll tracker
	JSR poll_tracker

	\\ Poll our VU effects
	JSR poll_fx

	\\ Update scrolltext
	JSR poll_scr

	\\ Poll the music player
	LDA player_ended

	.return
	RTS
}

.deinit_demo
{
	\\ Unhook Event vector - stops player
	JSR stop_eventv

	\\ Shutdown music player - silences all audio channels
	JSR deinit_player
	
	.return
	RTS
}

.demo_eventv
{
	php
	cmp #4
	bne not_vsync

	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

	\\ Poll the music player
	jsr poll_player

	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	File loading routines
\ ******************************************************************

.load_file_from_table			; flle_no = index into our table
{
	LDA file_no
	ASL A:ASL A: ASL A			; file_no * 8

	\\ Set osfile param block
	CLC
	ADC #LO(vgm_filenames)
	STA osfile_params + 0
	LDA #HI(vgm_filenames)
	ADC #0
	STA osfile_params + 1

	LDA #LO(VGM_stream_data)
	STA osfile_params + 2
	LDA #HI(VGM_stream_data)
	STA osfile_params + 3

	LDA #0
	STA osfile_params + 6

	\\ Issue osfile call
	LDX #LO(osfile_params)
	LDY #HI(osfile_params)
	LDA #&FF
	JSR osfile

	\\ Error?					; turns out DFS doesn't return error from osfile A=&FF..!
	LDA #0						; should return whether error occurred
	.return
	RTS
}

.load_eventv
{
	php
	cmp #4
	beq vsync
	JMP not_vsync

	.vsync
	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

\\ ***** Loading FX ***** \\

\\ Must be cheap otherwise will callback will re-enter!

	\\ Poll scroll
	JSR poll_scr
	
	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	Teletexel / MODE 7 functions & helpers
\ ******************************************************************

.teletexel_init						; set blank screen
{
	LDX #MODE7_contiguous
	LDY #MODE7_char_height - 1

	.loop
	TYA:PHA
	LDA #MODE7_graphic_black + 7
	JSR teletexel_set_row_start
	PLA:TAY
	DEY
	BPL loop

	.return
	RTS
}

.teletexel_set_row_start			; set row Y to char A, X
{
	PHA
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	LDY #0
	PLA
	STA (writeptr),Y
	TXA:INY
	STA (writeptr),Y

	.return
	RTS
}

.teletexel_erase_row				; row Y, start X, end A
{
	STA tmp_erase

	LDA mode7_row_addr_LO,Y
	STA loop+1
	LDA mode7_row_addr_HI,Y
	STA loop+2

	LDA #32
	.loop
	STA MODE7_base_addr,X			; **SELF-MODIFIED CODE**
	INX
	CPX tmp_erase
	BNE loop

	.return
	RTS	
}


\ ******************************************************************
\ *	Scrolltext code
\ * Redraws entire message each frame
\ * Only scrolls with byte precision, i.e. two pixels per frame
\ * This is too fast for a 5x5 pixel font
\ * TODO - rewrite to be single pixel scroll
\ ******************************************************************

.init_scr			; Y = y pos drawn at, A, X = address of message
{
	\\ Set address of message - **MODIFIES CODE**
	STA poll_scr_msg_addr_1+1
	STA poll_scr_msg_addr_2+1
	STX poll_scr_msg_addr_1+2
	STX poll_scr_msg_addr_2+2

	\\ Set address that scrolltext drawn to - **MODIFIES CODE**
	STY scr_y
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_1_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_1_addr+2
	INY
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_2_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_2_addr+2

	LDA #0
	STA scr_msg_idx
	STA scr_col

	.return
	RTS
}

.poll_scr
\\{
	\\ Copy our temp variables for drawing
	LDA scr_col
	LSR A
	STA tmp_cur_col				; current column in font

	\\ Set font load address
	BCC shifted_font

	\\ Not shifted
	LDA #LO(mode7_font_data)
	STA poll_scr_font_line1_addr + 1
	LDA #HI(mode7_font_data)
	STA poll_scr_font_line1_addr + 2

	JMP write_second_font_addr

	\\ Shifted by 1 pixel
	.shifted_font
	LDA #LO(mode7_font_data_shifted)
	STA poll_scr_font_line1_addr + 1
	LDA #HI(mode7_font_data_shifted)
	STA poll_scr_font_line1_addr + 2

	.write_second_font_addr
	CLC
	LDA poll_scr_font_line1_addr + 1
	ADC #MODE7_char_width
	STA poll_scr_font_line2_addr + 1
	LDA poll_scr_font_line1_addr + 2
	ADC #0
	STA poll_scr_font_line2_addr + 2

	LDA scr_msg_idx
	STA tmp_msg_idx				; current index into message

	\\ Loop over characters in row
	LDX #2						; X char position - ignore first two
	.poll_scr_xloop

	LDY tmp_msg_idx
	.poll_scr_msg_addr_1
	LDA demo_message,Y			; actually contains the offset into font data - **SELF-MODIFIED CODE**
	BNE poll_scr_not_end_of_msg			; finish if zero

	LDY #0
	STY tmp_msg_idx
	BEQ poll_scr_msg_addr_1

	.poll_scr_not_end_of_msg
	\\ Work out which column we're on
	CLC
	ADC tmp_cur_col
	TAY

	\\ Draw a column of the font to the screen
	.poll_scr_draw_col

	.poll_scr_font_line1_addr
	LDA mode7_font_data_shifted,Y	; **SELF-MODIFIED CODE**
	.poll_scr_line_1_addr
	STA &7C00,X						; **SELF-MODIFIED CODE**

	.poll_scr_font_line2_addr
	LDA mode7_font_data_shifted + MODE7_char_width,Y ; **SELF-MODIFIED CODE**
	.poll_scr_line_2_addr
	STA &7C28,X						; **SELF-MODIFIED CODE**

	\\ Next screen column
	INX
	CPX #MODE7_char_width
	BEQ poll_scr_done

	\\ Next font column
	INY

	INC tmp_cur_col
	LDA tmp_cur_col
	CMP #3
	BNE poll_scr_draw_col

	\\ Done all columns
	LDY #0
	STY tmp_cur_col

	INC tmp_msg_idx				; next letter

	JMP poll_scr_xloop

	.poll_scr_done
	INC scr_col					; increment column for scroll
	LDA scr_col
	CMP #6
	BNE poll_scr_return					; 8 columns

	LDA #0
	STA scr_col					; reset column
	INC scr_msg_idx				; next char in scr_message

	LDY scr_msg_idx
	.poll_scr_msg_addr_2
	LDA demo_message,Y			; **SELF-MODIFIED CODE**
	BNE poll_scr_return
	STA scr_msg_idx

	.poll_scr_return
	RTS
\\}


\ ******************************************************************
\ *	Graphic equaliser effect
\ ******************************************************************

.init_fx
{
	\\ Initialise the frequency array & beat bar array
	\\ freq_array is followed by chan_array, so we can process all together
	LDY #(FX_num_freqs+FX_num_channels) - 1
	LDA #0
	.loop
	STA freq_array,Y
	DEY
	BPL loop

	\\ hacky code to clear off the rogue bars left + right
	\\ better solution is to clean up screen layout
	LDX #0
	LDA #32
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	LDX #FX_chr_w+1
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	
	\\ code to reset the playtime bar, serves two purposes:
	\\ 1) resets the mockup
	\\ 2) erases any bars from the previously played track
	LDA #160+12
	LDX #FX_playtime_chrs-1
	.clear_playtime_loop
	STA FX_playtime_address, X
	DEX
	BPL clear_playtime_loop
	\\ set the first bar up
	LDA #160+29
	STA FX_playtime_address
	
	
	\\ init meta data vars
	LDA #0
	STA meta_idx
	STA meta_poll_count
	STA meta_clock_mins
	STA meta_clock_secs

	LDA #META_scroll_start_delay
	STA meta_timer

	.return
	RTS
}

\\ Render a 3 character high graphic beat bar
\\ A is the channel, X is the char offset
.draw_beat_bar
{
	TAY
	LDA chan_array, Y
	CLC
	ADC #1
	STA tmp_fx_y
	ASL A
	ASL A
	CLC
	ADC tmp_fx_y
	TAY
	
	\\ render a 3 byte bar column, 1 chr per bar
	LDA fx_table + 2, Y
	STA FX_address_beat+0, X
	LDA fx_table + 1, Y
	STA FX_address_beat+40, X
	LDA fx_table + 0, Y
	STA FX_address_beat+80, X

	RTS
}

.write_clock_at_writeptr			; X=mins, Y=secs
{
	TYA:PHA
	LDY #0

	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY

	LDA #':'
	STA (writeptr),Y
	INY

	\\ Count tens
	PLA
	LDX #0
	.loop_10
	CMP #10
	BCC done_10
	SEC
	SBC #10
	INX
	JMP loop_10
	.done_10
	PHA

	\\ Write tens
	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY

	\\ Write units
	PLA
	ADC #'0'
	STA (writeptr),Y
	INY

	.return
	RTS
}

.poll_fx				; A = render beat bars or not (0)
{
	PHA					; remember this for later

	\\ render the bar fx in 15 by 5 character columns
	LDX #0
	
	.fx_column_loop
	
	\\ get frequency level
	TXA
	
IF FX_num_freqs == 16
	LSR A
ENDIF

	TAY
	LDA freq_array, Y
	
	CLC
	ADC #1			; this hack forces levels to be a minimum of 1
					; which means there's always a green bar showing
					; fx_table lookup has a duplicated extra entry to prevent overread
	
	\\ mult*5 and lookup teletext bar graphic
	STA tmp_fx_y
	ASL A
	ASL A
	CLC
	ADC tmp_fx_y
	TAY
	
IF FX_num_freqs == 16
	\\ render the 5 byte bar column, 2 chrs per bar, 2nd bar has right hand column removed
	LDA fx_table + 4, Y
	STA FX_address_row0+0, X
	AND #&B5
	STA FX_address_row0+1, X
	LDA fx_table + 3, Y
	STA FX_address_row1+0, X
	AND #&B5
	STA FX_address_row1+1, X
	LDA fx_table + 2, Y
	STA FX_address_row2+0, X
	AND #&B5
	STA FX_address_row2+1, X
	LDA fx_table + 1, Y
	STA FX_address_row3+0, X
	AND #&B5
	STA FX_address_row3+1, X
	LDA fx_table + 0, Y
	STA FX_address_row4+0, X
	AND #&B5
	STA FX_address_row4+1, X
	\\ advance to next column
	INX
	INX
	TXA
	CMP #FX_num_freqs*2
ELSE
	\\ render the 5 byte bar column, 1 chr per bar
	LDA fx_table + 4, Y
	AND #&B5
	STA FX_address_row0+0, X
	LDA fx_table + 3, Y
	AND #&B5
	STA FX_address_row1+0, X
	LDA fx_table + 2, Y
	AND #&B5
	STA FX_address_row2+0, X
	LDA fx_table + 1, Y
	AND #&B5
	STA FX_address_row3+0, X
	LDA fx_table + 0, Y
	AND #&B5
	STA FX_address_row4+0, X
	\\ advance to next column
	INX
	TXA
	CMP #FX_num_freqs
ENDIF

	BNE fx_column_loop

	PLA:BEQ skip_beat_bars

	\\ Render the channel beat bars
	LDA #0
	LDX #FX_ch0_x
	JSR draw_beat_bar
	LDA #1
	LDX #FX_ch1_x
	JSR draw_beat_bar
	LDA #2
	LDX #FX_ch2_x
	JSR draw_beat_bar
	LDA #3
	LDX #FX_ch3_x
	JSR draw_beat_bar

	.skip_beat_bars
	
	\\ Let VU meter values fall to zero
	LDY #(FX_num_freqs) - 1
	.loop
	LDA freq_array,Y
	BEQ zero
	SEC
	SBC #1
	STA freq_array,Y
	.zero
	DEY
	BPL loop
	
	\\ Beat bars decay 2x faster
	LDY #(FX_num_channels) - 1
	.loop2
	LDA chan_array,Y
	BEQ zero2
	SEC
	SBC #1
	STA chan_array,Y
	BEQ zero2
	SEC
	SBC #1
	STA chan_array,Y	
	.zero2
	DEY
	BPL loop2
	
	\\ Update playtime bar
	INC playtime_counter
	BNE no_hi
	INC playtime_counter+1
	.no_hi
	LDA playtime_counter
	CMP playtime_interval
	BNE not_yet
	LDA playtime_counter+1
	CMP playtime_interval+1
	BNE not_yet
	
	\\ reset counter
	LDA #0
	STA playtime_counter
	STA playtime_counter+1
	
	\\ clear current graphic at offset (we'll update next chr in a mo)
	LDA playtime_index
	LSR A
	TAX
	LDA #160+12
	STA FX_playtime_address, X
	
	\\ increment playtime offset & render new bar graphic
	INC playtime_index

	\\ get the index, find chr X (index>>1, since 2 pixels per chr)
	LDA playtime_index
	TAY
	LSR A
	TAX
	TYA
	AND #1	; odd or even, lookup graphic chr
	TAY
	LDA playtime_table, Y
	STA FX_playtime_address, X
	
	.not_yet
	
	
	
	\\ Update meta data
	{
		DEC meta_timer
		BNE done_meta
	
		\\ Reset meta scroll timer
		LDA #META_scroll_update_delay
		STA meta_timer

		\\ Update meta index
		INC meta_idx
		LDA meta_idx
		CMP #PLAYER_string_max - META_max_width - 1
		BEQ longer_wait
		CMP #PLAYER_string_max - META_max_width
		BCC meta_no_wrap

		LDA #0
		STA meta_idx
		.longer_wait
		LDA #META_scroll_start_delay
		STA meta_timer

		\\ Copy meta data to screen
		.meta_no_wrap

		\\ End of string = idx + width clamped to string length
		\\ Start of string = end - width clamped to zero
		CLC
		LDA meta_idx
		ADC #META_max_width
		STA tmp_var				; end
	
		\\ Handle title end
		CMP player_song_title_len
		BCC title_end_safe
		LDA player_song_title_len
		.title_end_safe
		SEC
		SBC #META_max_width		; start
		BPL title_start_safe
		LDA #0
		.title_start_safe
		CLC
		ADC #LO(player_song_title)
		STA title_addr+1
		LDA #HI(player_song_title)
		ADC #0
		STA title_addr+2

		\\ Handle author end
		LDA tmp_var
		CMP player_song_author_len
		BCC author_end_safe
		LDA player_song_author_len
		.author_end_safe
		SEC
		SBC #META_max_width		; start
		BPL author_start_safe
		LDA #0
		.author_start_safe
		CLC
		ADC #LO(player_song_author)
		STA author_addr+1
		LDA #HI(player_song_author)
		ADC #0
		STA author_addr+2

		LDX #0
		.meta_loop
		.title_addr
		LDA player_song_title,X
		STA META_title_addr,X
		.author_addr
		LDA player_song_author,X
		STA META_author_addr,X
		INX
		CPX #META_max_width
		BNE meta_loop
		.done_meta
	}

	\\ Increment counter for clock
	{
		INC meta_poll_count
		LDA meta_poll_count
		CMP #PLAYER_sample_rate
		BNE not_sec_yet

		\\ Reset counter
		LDA #0
		STA meta_poll_count

		\\ Update 1 second
		INC meta_clock_secs
		LDA meta_clock_secs
		CMP #60
		BNE not_min_yet

		\\ Update 1 min
		INC meta_clock_mins
		LDA #0
		STA meta_clock_secs

		.not_min_yet

		\\ Display clock
		LDA #LO(META_clock_addr)
		STA writeptr
		LDA #HI(META_clock_addr)
		STA writeptr+1

		LDX meta_clock_mins
		LDY meta_clock_secs
		JSR write_clock_at_writeptr

		.not_sec_yet
	}

	.return
	RTS
}


\ ******************************************************************
\ *	Tracker scrolling display
\ ******************************************************************

.write_decimal_at		; A = number, X,Y = location on MODE 7 screen
{
	PHA
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	TXA:TAY

	\\ Count hundreds
	PLA
	LDX #0
	.loop_100
	CMP #100
	BCC done_100
	SEC
	SBC #100
	INX
	JMP loop_100
	.done_100
	PHA

	\\ Write hundreds
	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY
	
	\\ Count tens
	PLA
	LDX #0
	.loop_10
	CMP #10
	BCC done_10
	SEC
	SBC #10
	INX
	JMP loop_10
	.done_10
	PHA

	\\ Write tens
	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY

	\\ Write units
	CLC
	PLA
	ADC #'0'
	STA (writeptr),Y

	.return
	RTS
}

.mode7_copy_line				; copy line X to line Y
{
	\\ From line X
	LDA mode7_row_addr_LO,X
	STA readptr
	LDA mode7_row_addr_HI,X
	STA readptr+1

	\\ To line Y
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	LDY #0
	.loop
	LDA (readptr),Y
	STA (writeptr),Y
	INY
	CPY #MODE7_char_width
	BNE loop

	.return
	RTS
}

.copy_channel_fields			; copy channel fields only from line X to line Y
{
	\\ From line X
	LDA mode7_row_addr_LO,X
	STA readptr
	LDA mode7_row_addr_HI,X
	STA readptr+1

	\\ To line Y
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	\\ Tracker line number field
	LDY #TRACKER_lineno_field_xpos

	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 3 field
	LDY #TRACKER_ch3_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 2 field
	LDY #TRACKER_ch2_field_xpos

	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 1 field
	LDY #TRACKER_ch1_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Noise channel field
	LDY #TRACKER_noise_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	.return
	RTS
}

.write_note_name
{
	LDA note_name_table_0,X
	STA (writeptr),Y
	INY

	LDA note_name_table_1,X
	STA (writeptr),Y
	INY

	LDA note_name_table_2,X
	STA (writeptr),Y
	INY

	.return
	RTS
}

.write_note_blank
{
	LDA #'-'
	STA (writeptr),Y
	INY
	STA (writeptr),Y
	INY
	STA (writeptr),Y
	INY

	.return
	RTS
}

MACRO WRITE_VOL_CHAR
{
	LDA hex_to_ascii, X
	STA (writeptr),Y
}
ENDMACRO

MACRO WRITE_VOL_BLANK
{
	LDA #'-'
	STA (writeptr),Y
}
ENDMACRO

.poll_tracker
{
	\\ Temporary scroll values up - don't need to calc write addresses when locations fixed
	LDX #TRACKER_top_line_ypos + 1
	LDY #TRACKER_top_line_ypos
	JSR copy_channel_fields

	LDX #TRACKER_top_line_ypos + 2
	LDY #TRACKER_top_line_ypos + 1
	JSR copy_channel_fields

	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_top_line_ypos + 2
	JSR copy_channel_fields

	\\ **Should be writing our fields to active line!**

	LDX #TRACKER_bottom_line_ypos - 2
	LDY #TRACKER_active_line_ypos
	JSR copy_channel_fields

	LDX #TRACKER_bottom_line_ypos - 1
	LDY #TRACKER_bottom_line_ypos - 2
	JSR copy_channel_fields

	LDX #TRACKER_bottom_line_ypos
	LDY #TRACKER_bottom_line_ypos - 1
	JSR copy_channel_fields

	\\ **Instead writing our live data into bottom line!**
	\\ Write our current line number as decimal

	LDA player_counter
	LDX #TRACKER_lineno_field_xpos + 1			; +1 because leading 0 is constant
	LDY #TRACKER_bottom_line_ypos
	JSR write_decimal_at

	\\ Can reuse writeptr here - pointing to start of line we're writing!
	\\ Write channel values into fields - DO THIS BETTER?

	.write_field_channel3
	{
		LDY #12
		LDA player_reg_bits
		AND #SN_BIT_TONE3_FREQ		; channel 3 tone
		BEQ no_ch3_tone

		LDX player_reg_vals + SN_REG_TONE3_FREQ
		JSR write_note_name
		BNE try_ch3_vol		; OK because last instruction is INY

		.no_ch3_tone
		JSR write_note_blank

		.try_ch3_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE3_VOL		; channel 3 vol
		BEQ no_ch3_vol

		LDX player_reg_vals + SN_REG_TONE3_VOL
		WRITE_VOL_CHAR
		BNE done_ch3		; OK because A is char therefore not zero

		.no_ch3_vol
		WRITE_VOL_BLANK

		.done_ch3
	}

	.write_field_channel2
	{
		LDY #19
		LDA player_reg_bits
		AND #SN_BIT_TONE2_FREQ		; channel 2 tone
		BEQ no_ch2_tone

		LDX player_reg_vals + SN_REG_TONE2_FREQ
		JSR write_note_name
		BNE try_ch2_vol		; OK because last instruction is INY

		.no_ch2_tone
		JSR write_note_blank

		.try_ch2_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE2_VOL		; channel 2 vol
		BEQ no_ch2_vol

		LDX player_reg_vals + SN_REG_TONE2_VOL
		WRITE_VOL_CHAR
		BNE done_ch2		; OK because A is char therefore not zero

		.no_ch2_vol
		WRITE_VOL_BLANK

		.done_ch2
	}

	.write_field_channel1
	{
		LDY #26
		LDA player_reg_bits
		AND #SN_BIT_TONE1_FREQ		; channel 1 tone
		BEQ no_ch1_tone

		LDX player_reg_vals + SN_REG_TONE1_FREQ
		JSR write_note_name
		BNE try_ch1_vol		; OK because last instruction is INY

		.no_ch1_tone
		JSR write_note_blank

		.try_ch1_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE1_VOL		; channel 1 vol
		BEQ no_ch1_vol

		LDX player_reg_vals + SN_REG_TONE1_VOL
		WRITE_VOL_CHAR
		BNE done_ch1		; OK because A is char therefore not zero

		.no_ch1_vol
		WRITE_VOL_BLANK

		.done_ch1
	}

	.write_field_noise
	{
		LDY #33
		LDA player_reg_bits
		AND #SN_BIT_NOISE_CTRL		; noise channel control
		BEQ no_noise_tone

		\\ Check noise control
		LDA player_reg_vals + SN_REG_NOISE_CTRL
		AND #SN_FB_MASK
		BEQ noise_periodic
		LDA #'W'					; White Noise
		EQUB &2C					; = BIT noise_periodic => skip next two bytes
		.noise_periodic
		LDA #'P'					; Periodic Noise
		STA (writeptr),Y
		INY

		LDA player_reg_vals + SN_REG_NOISE_CTRL
		AND #SN_NF_MASK
		ASL A						; *2
		TAX
		LDA noise_note_0,X			; noise_note = Lo,Me,Hi,T1	
		STA (writeptr),Y
		INY
		LDA noise_note_0+1,X		; 2nd char
		STA (writeptr),Y
		INY

		BNE try_noise_vol			; OK because last instruction is INY

		.no_noise_tone
		JSR write_note_blank

		.try_noise_vol
		LDA player_reg_bits
		AND #SN_BIT_NOISE_VOL		; noise channel vol
		BEQ no_noise_vol

		LDX player_reg_vals + SN_REG_NOISE_VOL
		WRITE_VOL_CHAR
		BNE done_noise				; OK because A is char therefore not zero

		.no_noise_vol
		WRITE_VOL_BLANK	

		.done_noise
	}

	\\ Duplicate line 17 to line 18 for double height
	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_dupe_line_ypos
	JSR mode7_copy_line

	.return
	RTS
}



\ ******************************************************************
\ *	Event Vector Routines
\ ******************************************************************

.start_eventv				; new event handler in X,Y
{
	\\ Remove interrupt instructions
	lda #NOP_OP
	sta PSG_STROBE_SEI_INSN
	sta PSG_STROBE_CLI_INSN
	
	\\ Set new Event handler
	sei
	LDA EVENTV
	STA old_eventv
	LDA EVENTV+1
	STA old_eventv+1

	stx EVENTV
	sty EVENTV+1
	cli
	
	\\ Enable VSYNC event.
	lda #14
	ldx #4
	jsr osbyte
	rts
}
	
.stop_eventv
{
	\\ Disable VSYNC event.
	lda #13
	ldx #4
	jsr osbyte

	\\ Reset old Event handler
	SEI
	LDA old_eventv
	STA EVENTV
	LDA old_eventv+1
	STA EVENTV+1
	CLI 

	\\ Insert interrupt instructions back
	lda #SEI_OP
	sta PSG_STROBE_SEI_INSN
	lda #CLI_OP
	sta PSG_STROBE_CLI_INSN
	rts
}


\ ******************************************************************
\ *	Debug helpers
\ ******************************************************************

IF _DEBUG
.debug_print_A				; trashes X
{
	PHA:PHA
	LSR A:LSR A:LSR A:LSR A
	TAX
	LDA hex_to_ascii,X
	JSR oswrch
	PLA
	AND #&0F
	TAX
	LDA hex_to_ascii,X
	JSR oswrch
	LDA #32
	JSR oswrch
	PLA
	RTS
}
ENDIF




\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

.lookup_tables_start

\\ Start address of each row in MODE 7 - wasteful but helpful
.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

\\ 16 Arrangements of 5 teletext character bytes to render a vertical equalizer bar
.fx_table
EQUB 160, 160, 160, 160, 160
EQUB 160+80, 160, 160, 160, 160
EQUB 160+92, 160, 160, 160, 160
EQUB 160+95, 160, 160, 160, 160
EQUB 160+95, 160+80, 160, 160, 160
EQUB 160+95, 160+92, 160, 160, 160
EQUB 160+95, 160+95, 160, 160, 160
EQUB 160+95, 160+95, 160+80, 160, 160
EQUB 160+95, 160+95, 160+92, 160, 160
EQUB 160+95, 160+95, 160+95, 160, 160
EQUB 160+95, 160+95, 160+95, 160+80, 160
EQUB 160+95, 160+95, 160+95, 160+92, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160+80
EQUB 160+95, 160+95, 160+95, 160+95, 160+92
EQUB 160+95, 160+95, 160+95, 160+95, 160+95
EQUB 160+95, 160+95, 160+95, 160+95, 160+95	; last row copied to enable fixed bar effect

.playtime_table
EQUB 160+29, 160+78	; 160+12 for 'empty' middle line dash

.num_to_bit				; look up bit N
EQUB &01, &02, &04, &08, &10, &20, &40, &80

.hex_to_ascii			; for volume print
EQUS "0123456789abcdef"

.noise_note_0 EQUS "Lo"
.noise_note_1 EQUS "Md"
.noise_note_2 EQUS "Hi"
.noise_note_3 EQUS "T1"

.note_tables_start

\\ Note name lookup table, index using upper 8 bits of a 10-bit tone value.
\\ Not mega accurate, but fast, and good enough for a reasonably convincing visual 
;ALIGN &100		; doesn't need to be page aligned
.note_name_table_0 EQUS "AAAAGECAFEDCAGGFEDDCCCAGGGFFFEDDDDCCCCAAGGGGGFFFFFFEEEDDDDDDCCCCCCCCAAAAGGGGGGGGFFFFFFFFFFEEEEEDDDDDDDDDDDDCCCCCCCCCCCCCBBBBBBBAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGFFFFFFFFFFFFFFFFFFFEEEEEEEEEEEDDDDDDDDDDDDDDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBAA"
;note_name_table_1 EQUS "----#-#-#--#-#---#-#---#--#---##--##----###--###------###---####--------####----#####----------######------######--------------########--------########---------#########---------------------###########------------#############----------------------------##"
\\ Quirk of MODE 7: ASCII 35='#' but in gfx mode 35+128='£' so need to use ASCII 95='_' so in gfx mode 95+128='#'
.note_name_table_1 EQUS "----_-_-_--_-_---_-_---_--_---__--__----___--___------___---____--------____----_____----------______------______--------------________--------________---------_________---------------------___________------------_____________----------------------------__"
.note_name_table_2 EQUS "9999999888887777777777666666666666666655555555555555555555555555555544444444444444444444444444444444444444444444444444443333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333322222222222222222"

.note_tables_end

.lookup_tables_end


