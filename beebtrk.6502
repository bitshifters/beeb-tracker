\ ******************************************************************
\ * Beeb Tracker
\ * Music player & visualiser in MODE 7
\ * Kieran Connell & Simon Morris
\ * Demo team name TBD! :)
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

osfile = &FFDD
oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
EVENTV = &0220

\\ Internal Key Number not INKEY!
IKN_esc = 112
IKN_up = 57
IKN_down = 41
IKN_return = 73
IKN_q = 16
IKN_a = 65

\\ Opcodes
SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea

\\ SN Register Values
SN_REG_MASK = &70
SN_REG_TONE3_FREQ = 0
SN_REG_TONE3_VOL = 1
SN_REG_TONE2_FREQ = 2
SN_REG_TONE2_VOL = 3
SN_REG_TONE1_FREQ = 4
SN_REG_TONE1_VOL = 5
SN_REG_NOISE_CTRL = 6
SN_REG_NOISE_VOL = 7
SN_REG_MAX = 8

\\ SN Register Bit-field
SN_BIT_TONE3_FREQ = &01
SN_BIT_TONE3_VOL = &02
SN_BIT_TONE2_FREQ = &04
SN_BIT_TONE2_VOL = &08
SN_BIT_TONE1_FREQ = &10
SN_BIT_TONE1_VOL = &20
SN_BIT_NOISE_CTRL = &40
SN_BIT_NOISE_VOL = &80

\\ SN Frequency Constants
SN_FREQ_BYTE_MASK = &80
SN_FREQ_FIRST_BYTE_MASK = &0F
SN_FREQ_SECOND_BYTE_MASK = &3F

\\ SN Volume Constants
SN_VOL_MASK = &0F
SN_VOL_MAX = &0F

\\ Noise Freqency Vaues
SN_NF_MASK = &03
SN_NF_LOW = 0
SN_NF_MED = 1
SN_NF_HIGH = 2
SN_NF_TONE1 = 3

\\ Noise Frequency Type
SN_FB_MASK = &04
SN_FB_PERIODIC = 0
SN_FB_WHITENOISE = &04


\ ******************************************************************
\ *	Define debug flags
\ ******************************************************************

_DEBUG = TRUE
ENABLE_EXIT = FALSE

\ ******************************************************************
\ *	Define global macros
\ ******************************************************************


\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_buffer_len = 1024

\\ MODE 7
MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25
MODE7_texel_width = (MODE7_char_width - 2) * 2
MODE7_texel_height = MODE7_char_height * 3

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154


\ ******************************************************************
\ *	Define app constants
\ ******************************************************************

\\ Number of entries in our file table
NUM_vgm_files = 4				; size of our file table

\\ VU & beat bar FX
FX_num_freqs = 32				; number of VU bars - can be 16 or 32
FX_num_channels = 4				; number of beat bars (one per channel)

FX_chr_x = 4
FX_chr_y = 8
FX_chr_w = 32
FX_chr_h = 5
FX_address = MODE7_base_addr + FX_chr_y*40 + FX_chr_x
FX_address_row0 = FX_address
FX_address_row1 = FX_address_row0 + 40
FX_address_row2 = FX_address_row1 + 40
FX_address_row3 = FX_address_row2 + 40
FX_address_row4 = FX_address_row3 + 40

\\ Channel beat bar locations - beat bars are 3 chrs high
FX_address_beat = MODE7_base_addr + 40*14
FX_ch0_x = 10
FX_ch1_x = 17
FX_ch2_x = 24
FX_ch3_x = 31

\\ Tracker screen setup
TRACKER_lineno_field_xpos = 4
TRACKER_ch3_field_xpos = 12
TRACKER_ch2_field_xpos = 19
TRACKER_ch1_field_xpos = 26
TRACKER_noise_field_xpos = 33

TRACKER_top_line_ypos = 14
TRACKER_active_line_ypos = 17
TRACKER_dupe_line_ypos = 18
TRACKER_bottom_line_ypos = 21

\\ Menu screen setup
MENU_entry_xpos = 3
MENU_entry_width = 34
MENU_top_line_ypos = 16
MENU_bottom_line_ypos = 21
MENU_overlay_ypos = 14
MENU_overlay_size = 8 * MODE7_char_width				; 8 lines of 40 chars
MENU_overlay_dst_addr = MODE7_base_addr + MENU_overlay_ypos * MODE7_char_width

\\ Menu key config
MENU_key_toggle = IKN_esc
MENU_key_up = IKN_up
MENU_key_down = IKN_down
MENU_key_select = IKN_return


\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_zp_src_hi = $70
EXO_zp_src_lo = EXO_zp_src_hi + 1
EXO_zp_src_bi = EXO_zp_src_hi + 2
EXO_zp_bitbuf = EXO_zp_src_hi + 3

EXO_zp_len_lo  = $74
EXO_zp_len_hi  = EXO_zp_len_lo + 1

EXO_zp_bits_lo = $76
EXO_zp_bits_hi = EXO_zp_bits_lo + 1

EXO_zp_dest_hi = $78
EXO_zp_dest_lo = EXO_zp_dest_hi + 1	; dest addr lo
EXO_zp_dest_bi = EXO_zp_dest_hi + 2	; dest addr hi

\\ Our own app variables
ORG &7B
GUARD &9F

\\ Player vars
.player_ended			SKIP 1		; non-zero when player has reached end of tune
.player_data			SKIP 1		; temporary variable when decoding sound data - must be separate as player running on events
.player_last_reg		SKIP 1		; last channel (register) refered to by the VGM sound data

.player_counter			SKIP 1		; increments by 1 every poll (20ms) - used as our tracker line no. & to sync fx with audio update
.player_reg_bits		SKIP 1		; bits 0 - 7 set if SN register 0 - 7 updated this frame, cleared at start of player poll

\\ Temporary vars
.tmp_var				; SHARED	; free for any function to use but not preserved across subroutines
.tmp_erase				SKIP 1		; used when erasing rows or pixels

.tmp_col_mask			; SHARED	; scr_init only - used to rotate font glyph data
.tmp_cur_col			; SHARED	; poll_scr only - current column into font
.tmp_fx_y				SKIP 1		; poll_fx only - current y value being plotted

.tmp_row_bit			; SHARED	; scr_init only - used to rotate font glyph data
.tmp_font_byte			SKIP 1		; poll_scr only - current byte of font data

.tmp_msg_idx			SKIP 1		; current index into scr_message - only used during poll_scr

\\ Generic vars
.writeptr				SKIP 2		; generic write ptr
.readptr				SKIP 2		; generic read ptr

\\ Scroll text vars
.scr_msg_idx			SKIP 1		; index into scr_message
.scr_col				SKIP 1		; current column in first character to be displayed
.scr_y					SKIP 1		; y coordinate of scroll text

\\ Loading state vars
.load_x					SKIP 1		; animated pixel x
.load_y					SKIP 1		; animated pixel y

\\ App state vars
.file_no				SKIP 1		; index into our file table
.menu_old_file			SKIP 1
.menu_key_held			SKIP 1

\\ System vars
.old_eventv				SKIP 2


\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1900	      					; code origin - assume standard BBC Micro
GUARD MODE7_base_addr				; ensure code size doesn't hit start of screen memory

.start


\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop including high-level state machine
\ ******************************************************************

.main
{
\\ ***** System initialise ***** \\

	\\ Set MODE 7
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch

	\\ Must be a simpler way to turn off cursor than this!!
	LDA #23: JSR oswrch
	LDA #1: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch

	\\ Debounce
	LDA #&FF
	STA menu_key_held

	\\ Load first file in our list
	LDA #0
	STA file_no


	\\ Intro screen goes here \\

	
\\ ***** Loading state ***** \\

	.loading_state
	{
		\\ Clear screen
		LDA #12: JSR oswrch
		JSR teletexel_init

		\\ Init scrolltext with loading message
		LDA #LO(load_message):LDX #HI(load_message)
		LDY #11:JSR init_scr

		\\ Start our event driven fx
		ldx #LO(load_eventv)
		ldy #HI(load_eventv)
		JSR start_eventv

		\\ Blocking file load
		JSR load_file_from_table
		PHA							; store return value

		\\ Kill our event driven fx
		JSR stop_eventv

		\\ Returned error?
		PLA
		BEQ no_error

		\\ Handle error (exit)
		JMP return
		
		.no_error
	}

\\ ***** Demo (Tracker) state ***** \\

	\\ Initialise demo state
	JSR init_demo

	.enter_demo_state

	\\ Technically should populate the tracker display with genuine music data here!
	\\ But at 20ms per line it fills up with data in a 140ms so is hardly noticable...

	\\ Demo loop
	.demo_loop
	{
		\\ Check for pressed keys
		LDA #121
		LDX #&10
		JSR osbyte

		\\ Still holding same key
		CPX menu_key_held
		BEQ no_key_pressed

		\\ Remember current key
		STX menu_key_held

		\\ Any key pressed?
		CPX #&FF
		BEQ no_key_pressed

		\\ Check escape
		CPX #MENU_key_toggle
		BEQ enter_menu_state

		.no_key_pressed

		\\ Poll the music player
		LDA player_ended
		BNE song_ended

		\\ Wait for vsync - NO LONGER WAITING FOR VSYNC
		;LDA #19
		;JSR osbyte

		\\ Actually sync to audio instead
		LDA player_counter
		.wait_for_audio_sync
		CMP player_counter
		BEQ wait_for_audio_sync

		\\ At this point we know audio data has just been sent to SN
		\\ So all of our vars from the player are fresh
		\\ Use these to render our demo FX (before next vsync!)
		\\ May still want to do something clever to avoid flicker

		\\ Poll tracker
		JSR poll_tracker

		\\ Poll our VU effects
		LDA #&FF				; we do want beat bars
		JSR poll_fx

		\\ Update scrolltext
		JSR poll_scr

		\\ Loop
		JMP demo_loop

		.song_ended

		\\ Deinitialise demo state
		JSR deinit_demo

		\\ Increment file in table
		LDX file_no
		INX
		CPX #NUM_vgm_files
		BCC next_file
		LDX #0
		.next_file
		STX file_no

		\\ Automatically load next file
		JMP loading_state
	}

\\ ***** Menu state ***** \\

	.enter_menu_state

	\\ Initialise menu state

	JSR init_menu
	JSR menu_populate

	\\ Menu loop
	.menu_loop
	{
		\\ Check for pressed keys
		LDA #121
		LDX #&10
		JSR osbyte

		\\ Still holding same key
		CPX menu_key_held
		BEQ no_key_pressed

		\\ Remember current key
		STX menu_key_held

		\\ Any key pressed?
		CPX #&FF
		BEQ no_key_pressed

		\\ Check escape
		CPX #MENU_key_toggle
		BNE not_escape

		\\ Handle toggle key
		\\ Revert file no
		LDA menu_old_file
		STA file_no

		\\ Cancel menu
		.cancel_menu
		JSR deinit_menu
		JMP enter_demo_state

		.not_escape
		CPX #MENU_key_up
		BNE not_up

		\\ Handle up key
		\\ Decrement file_no no lower than 0
		LDA file_no
		BEQ not_up
		DEC file_no

		\\ Update our menu on screen
		JSR menu_populate
		JMP no_key_pressed

		.not_up
		CPX #MENU_key_down
		BNE not_down

		\\ Handle down
		\\ Increment file_no up to MAX
		LDA file_no
		IF ENABLE_EXIT
		CMP #NUM_vgm_files
		ELSE
		CMP #NUM_vgm_files - 1
		ENDIF
		BEQ not_down
		INC file_no

		\\ Update our menu on screen
		JSR menu_populate
		JMP no_key_pressed

		.not_down
		CPX #MENU_key_select
		BNE not_select

		\\ Handle select key
		\\ Check if we're on the same track
		LDA file_no
		CMP menu_old_file
		BEQ cancel_menu

		\\ Deinit the menu
		JSR deinit_menu

		\\ Deinit the demo
		JSR deinit_demo

		\\ Either file load or exit
		LDA file_no
		CMP #NUM_vgm_files
		BEQ exit_app

		\\ Load new file
		JMP loading_state

		.not_select
		.no_key_pressed

		\\ If track has ended just keep menu around until user action
		LDA player_ended
		BEQ sync_to_audio
		
		\\ If no audio then sync to vsync instead!
		LDA #19
		JSR osbyte
		BNE skip_audio_sync

		\\ Sync to audio
		.sync_to_audio
		LDA player_counter
		.wait_for_audio_sync
		CMP player_counter
		BEQ wait_for_audio_sync

		.skip_audio_sync

		\\ Poll our VU effects
		LDA #0					; we don't want beat bars
		JSR poll_fx

		\\ Update scrolltext
		JSR poll_scr

		\\ Loop
		JMP menu_loop

		.exit_app
	}

\\ ***** Exit app entirely ***** \\

	\\ Credits / Outro screen goes here \\

	\\ Exit cleanly - tidy up anything else here!
	LDA #12: JSR oswrch

	\\ Would be nice to clear escape state and issue BASIC NEW to avoid "Bad Program" error

	.return
	RTS
}


\ ******************************************************************
\ *	Menu state routines
\ ******************************************************************

.init_menu
{
	\\ Copy menu overlay to screen - 8x lines from line 14
	LDX #0
	.loop
	LDA MENU_overlay_src_addr, X
	STA MENU_overlay_dst_addr, X
	INX
	BNE loop

	LDX #(MENU_overlay_size - 1) - &100
	.loop2
	LDA MENU_overlay_src_addr + &100, X
	STA MENU_overlay_dst_addr + &100, X
	DEX
	BPL loop2

	\\ Remember stuff
	LDA file_no
	STA menu_old_file

	.return
	RTS
}

.menu_populate
{
	\\ Populate our menu with entries based on file_no
	LDA file_no
	SEC
	SBC #1
	TAX

	LDY #MENU_top_line_ypos

	.loop
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	TXA:PHA
	BPL positive

	.clamp
	\\ Write blank line
	LDX #MENU_entry_xpos:LDA #MENU_entry_xpos + MENU_entry_width
	JSR teletexel_erase_row
	JMP next

	.positive
	IF ENABLE_EXIT
	CPX #NUM_vgm_files+1			; include quit option
	ELSE
	CPX #NUM_vgm_files				; don't include quit option
	ENDIF
	BCS clamp
	
	\\ Write entry from loading_table
	TXA:ASL A:TAX

	LDA menu_table,X
	STA write_loop+1
	LDA menu_table+1,X
	STA write_loop+2

	\\ Store Y
	TYA:PHA

	LDX #0
	LDY #MENU_entry_xpos
	.write_loop
	LDA menu_entry_1,X
	STA (writeptr),Y
	INY
	INX
	CPX #MENU_entry_width
	BNE write_loop

	PLA:TAY

	.next
	PLA:TAX
	INX

	INY
	CPY #TRACKER_dupe_line_ypos
	BNE not_dupe
	INY
	.not_dupe
	CPY #MENU_bottom_line_ypos + 1
	BNE loop

	\\ Duplicate line 17 to line 18 for double height
	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_dupe_line_ypos
	JSR mode7_copy_line

	.return
	RTS
}

.deinit_menu
{
	\\ Copy original tracker back to screen - 8x lines from line 14
	LDX #0
	.loop
	LDA MENU_original_src_addr, X
	STA MENU_overlay_dst_addr, X
	INX
	BNE loop

	LDX #(MENU_overlay_size - 1) - &100
	.loop2
	LDA MENU_original_src_addr + &100, X
	STA MENU_overlay_dst_addr + &100, X
	DEX
	BPL loop2

	.return
	RTS
}


\ ******************************************************************
\ *	Demo state routines
\ ******************************************************************

.init_demo
{
	\\ Set load and store addresses
	\\ Is it really necessary to use self-modifying code here?!

	LDA #LO(mode7_screen_data)
	STA loop+1
	LDA #HI(mode7_screen_data)
	STA loop+2

	LDA #LO(MODE7_base_addr)
	STA loop+4
	LDA #HI(MODE7_base_addr)
	STA loop+5

	\\ Initialise MODE 7 screen
	LDY #0
	.loop
	LDA mode7_screen_data,Y				; **SELF-MODIFIED CODE**
	STA MODE7_base_addr,Y				; **SELF-MODIFIED CODE**

	INY
	BNE loop
	INC loop + 2						; increment read address hi byte
	INC loop + 5						; increment write address hi byte
	BPL loop							; until >= &8000

	\\ Initialise our effects
	JSR init_fx

	LDA #LO(demo_message): LDX #HI(demo_message)
	LDY #23: JSR init_scr				; top of scroller at Y

	\\ Initialise exomizer - must have some data ready to decrunch
	LDX #LO(VGM_stream_data - 1)
	LDY #HI(VGM_stream_data - 1)
	JSR init_decruncher

	\\ Initialise music player - consumes first crunched byte
	JSR	init_player

	\\ Hook up Event vector - starts player
	ldx #LO(demo_eventv)
	ldy #HI(demo_eventv)
	JSR start_eventv

	.return
	RTS
}

.poll_demo
{
	\\ Poll tracker
	JSR poll_tracker

	\\ Poll our VU effects
	JSR poll_fx

	\\ Update scrolltext
	JSR poll_scr

	\\ Poll the music player
	LDA player_ended

	.return
	RTS
}

.deinit_demo
{
	\\ Unhook Event vector - stops player
	JSR stop_eventv

	\\ Shutdown music player - silences all audio channels
	JSR deinit_player
	
	.return
	RTS
}

.demo_eventv
{
	php
	cmp #4
	bne not_vsync

	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

	\\ Poll the music player
	jsr poll_player

	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	File loading routines
\ ******************************************************************

.load_file_from_table			; flle_no = index into our table
{
	LDA file_no
	ASL A:TAX

	\\ Set osfile param block
	LDA loading_table,X
	STA osfile_params + 0
	LDA loading_table+1,X
	STA osfile_params + 1

	LDA #LO(VGM_stream_data)
	STA osfile_params + 2
	LDA #HI(VGM_stream_data)
	STA osfile_params + 3

	LDA #0
	STA osfile_params + 6

	\\ Issue osfile call
	LDX #LO(osfile_params)
	LDY #HI(osfile_params)
	LDA #&FF
	JSR osfile

	\\ Error?
	LDA #0						; should return whether error occurred
	.return
	RTS
}

.load_eventv
{
	php
	cmp #4
	beq vsync
	JMP not_vsync

	.vsync
	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

\\ ***** Loading FX ***** \\

\\ Must be cheap otherwise will callback will re-enter!

	\\ Remove old pixel
	LDX load_x
	LDY load_y
	JSR teletexel_erase

	\\ Update pixel pos - just move left to right, top to bottom
	LDX load_x
	LDY load_y
	INX:INX
	CPX #MODE7_texel_width
	BCC no_wrapx
	INY:INY
	CPY #MODE7_texel_height
	BCC no_wrapy
	LDY #0
	.no_wrapy
	STY load_y
	LDX #0
	.no_wrapx
	STX load_x
	
	\\ Draw new pixel
	JSR teletexel_plot

	\\ Poll scroll
	JSR poll_scr
	
	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	Teletexel / MODE 7 functions & helpers
\ ******************************************************************

.teletexel_init						; set blank screen
{
	LDX #MODE7_contiguous
	LDY #MODE7_char_height - 1

	.loop
	TYA:PHA
	LDA #MODE7_graphic_black + 7
	JSR teletexel_set_row_start
	PLA:TAY
	DEY
	BPL loop

	.return
	RTS
}

.teletexel_set_row_start			; set row Y to char A, X
{
	PHA
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	LDY #0
	PLA
	STA (writeptr),Y
	TXA:INY
	STA (writeptr),Y

	.return
	RTS
}

.teletexel_erase_row				; row Y, start X, end A
{
	STA tmp_erase

	LDA mode7_row_addr_LO,Y
	STA loop+1
	LDA mode7_row_addr_HI,Y
	STA loop+2

	LDA #32
	.loop
	STA MODE7_base_addr,X			; **SELF-MODIFIED CODE**
	INX
	CPX tmp_erase
	BNE loop

	.return
	RTS	
}

MACRO TELETEXEL_CALC_WRITEPTR_AND_MASK				; preserves X destroys A & Y
{
	\\ Turn texel y into address of row
	LDA mode7_texel_y_to_row_addr_LO,Y				; 4c
	STA writeptr									; 3c
	LDA mode7_texel_y_to_row_addr_HI,Y				; 4c
	STA writeptr+1									; 3c

	\\ Add x character offset
	TXA												; 2c
	LSR A											; 2c
	BCS odd											; 3c

	\\ Even
	.even
	\\ We know carry is clear
	ADC writeptr									; 3c
	STA writeptr									; 3c
	BCC no_carry_even								; 3c
	INC writeptr+1									; 5c
	.no_carry_even
	LDA mode7_texel_lookup_x_even,Y					; 4c
	JMP plot_texel									; 3c

	\\ Odd
	.odd
	CLC												; 2c
	ADC writeptr									; 3c
	STA writeptr									; 3c
	BCC no_carry_odd								; 3c
	INC writeptr+1									; 5c
	.no_carry_odd
	LDA mode7_texel_lookup_x_odd,Y					; 4c

	.plot_texel
}													; odd = 41c even = 42c  (not including EOR & STA)
ENDMACRO

.teletexel_plot_eor									; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	LDY #0											; 2c - not needed on MASTER
	EOR (writeptr),Y								; 6c
	STA (writeptr),Y								; 6c

	.return
	RTS												
}													; total = 42+14 = 56c (not including RTS)

.teletexel_plot										; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	LDY #0											; 2c
	ORA (writeptr),Y								; 6c
	STA (writeptr),Y								; 6c

	.return
	RTS
}	

.teletexel_erase									; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	EOR #&FF										; flip the bits
	STA tmp_erase
	LDY #0											; 2c
	LDA (writeptr),Y								; 6c
	AND tmp_erase
	STA (writeptr),Y								; 6c

	.return
	RTS
}	


\ ******************************************************************
\ *	Scrolltext code
\ * Redraws entire message each frame
\ * Only scrolls with byte precision, i.e. two pixels per frame
\ * This is too fast for a 5x5 pixel font
\ * TODO - rewrite to be single pixel scroll
\ ******************************************************************

.init_scr			; Y = y pos drawn at, A, X = address of message
{
	\\ Set address of message - **MODIFIES CODE**
	STA poll_scr_msg_addr_1+1
	STA poll_scr_msg_addr_2+1
	STX poll_scr_msg_addr_1+2
	STX poll_scr_msg_addr_2+2

	\\ Set address that scrolltext drawn to - **MODIFIES CODE**
	STY scr_y
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_1_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_1_addr+2
	INY
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_2_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_2_addr+2

	LDA #0
	STA scr_msg_idx
	STA scr_col

	.return
	RTS
}

.poll_scr
\\{
	\\ Copy our temp variables for drawing
	LDA scr_col
	LSR A
	STA tmp_cur_col				; current column in font

	\\ Set font load address
	BCC shifted_font

	\\ Not shifted
	LDA #LO(mode7_font_data)
	STA poll_scr_font_line1_addr + 1
	LDA #HI(mode7_font_data)
	STA poll_scr_font_line1_addr + 2

	JMP write_second_font_addr

	\\ Shifted by 1 pixel
	.shifted_font
	LDA #LO(mode7_font_data_shifted)
	STA poll_scr_font_line1_addr + 1
	LDA #HI(mode7_font_data_shifted)
	STA poll_scr_font_line1_addr + 2

	.write_second_font_addr
	CLC
	LDA poll_scr_font_line1_addr + 1
	ADC #MODE7_char_width
	STA poll_scr_font_line2_addr + 1
	LDA poll_scr_font_line1_addr + 2
	ADC #0
	STA poll_scr_font_line2_addr + 2

	LDA scr_msg_idx
	STA tmp_msg_idx				; current index into message

	\\ Loop over characters in row
	LDX #2						; X char position - ignore first two
	.poll_scr_xloop

	LDY tmp_msg_idx
	.poll_scr_msg_addr_1
	LDA demo_message,Y			; actually contains the offset into font data - **SELF-MODIFIED CODE**
	BNE poll_scr_not_end_of_msg			; finish if zero

	LDY #0
	STY tmp_msg_idx
	BEQ poll_scr_msg_addr_1

	.poll_scr_not_end_of_msg
	\\ Work out which column we're on
	CLC
	ADC tmp_cur_col
	TAY

	\\ Draw a column of the font to the screen
	.poll_scr_draw_col

	.poll_scr_font_line1_addr
	LDA mode7_font_data_shifted,Y	; **SELF-MODIFIED CODE**
	.poll_scr_line_1_addr
	STA &7C00,X						; **SELF-MODIFIED CODE**

	.poll_scr_font_line2_addr
	LDA mode7_font_data_shifted + MODE7_char_width,Y ; **SELF-MODIFIED CODE**
	.poll_scr_line_2_addr
	STA &7C28,X						; **SELF-MODIFIED CODE**

	\\ Next screen column
	INX
	CPX #MODE7_char_width
	BEQ poll_scr_done

	\\ Next font column
	INY

	INC tmp_cur_col
	LDA tmp_cur_col
	CMP #3
	BNE poll_scr_draw_col

	\\ Done all columns
	LDY #0
	STY tmp_cur_col

	INC tmp_msg_idx				; next letter

	JMP poll_scr_xloop

	.poll_scr_done
	INC scr_col					; increment column for scroll
	LDA scr_col
	CMP #6
	BNE poll_scr_return					; 8 columns

	LDA #0
	STA scr_col					; reset column
	INC scr_msg_idx				; next char in scr_message

	LDY scr_msg_idx
	.poll_scr_msg_addr_2
	LDA demo_message,Y			; **SELF-MODIFIED CODE**
	BNE poll_scr_return
	STA scr_msg_idx

	.poll_scr_return
	RTS
\\}


\ ******************************************************************
\ *	Graphic equaliser effect
\ ******************************************************************

.init_fx
{
	\\ Initialise the frequency array & beat bar array
	\\ freq_array is followed by chan_array, so we can process all together
	LDY #(FX_num_freqs+FX_num_channels) - 1
	LDA #0
	.loop
	STA freq_array,Y
	DEY
	BPL loop

	\\ hacky code to clear off the rogue bars left + right
	\\ better solution is to clean up screen layout
	LDX #0
	LDA #32
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	LDX #FX_chr_w+1
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	
	.return
	RTS
}

\\ Render a 3 character high graphic beat bar
\\ A is the channel, X is the char offset
.draw_beat_bar
{
	TAY
	LDA chan_array, Y
	CLC
	ADC #1
	STA tmp_fx_y
	ASL A
	ASL A
	CLC
	ADC tmp_fx_y
	TAY
	
	\\ render a 3 byte bar column, 1 chr per bar
	LDA fx_table + 2, Y
	STA FX_address_beat+0, X
	LDA fx_table + 1, Y
	STA FX_address_beat+40, X
	LDA fx_table + 0, Y
	STA FX_address_beat+80, X

	RTS
}

.poll_fx				; A = render beat bars or not (0)
{
	PHA					; remember this for later

	\\ render the bar fx in 15 by 5 character columns
	LDX #0
	
	.fx_column_loop
	
	\\ get frequency level
	TXA
	
IF FX_num_freqs == 16
	LSR A
ENDIF

	TAY
	LDA freq_array, Y
	
	CLC
	ADC #1			; this hack forces levels to be a minimum of 1
					; which means there's always a green bar showing
					; fx_table lookup has a duplicated extra entry to prevent overread
	
	\\ mult*5 and lookup teletext bar graphic
	STA tmp_fx_y
	ASL A
	ASL A
	CLC
	ADC tmp_fx_y
	TAY
	
IF FX_num_freqs == 16
	\\ render the 5 byte bar column, 2 chrs per bar, 2nd bar has right hand column removed
	LDA fx_table + 4, Y
	STA FX_address_row0+0, X
	AND #&B5
	STA FX_address_row0+1, X
	LDA fx_table + 3, Y
	STA FX_address_row1+0, X
	AND #&B5
	STA FX_address_row1+1, X
	LDA fx_table + 2, Y
	STA FX_address_row2+0, X
	AND #&B5
	STA FX_address_row2+1, X
	LDA fx_table + 1, Y
	STA FX_address_row3+0, X
	AND #&B5
	STA FX_address_row3+1, X
	LDA fx_table + 0, Y
	STA FX_address_row4+0, X
	AND #&B5
	STA FX_address_row4+1, X
	\\ advance to next column
	INX
	INX
	TXA
	CMP #FX_num_freqs*2
ELSE
	\\ render the 5 byte bar column, 1 chr per bar
	LDA fx_table + 4, Y
	AND #&B5
	STA FX_address_row0+0, X
	LDA fx_table + 3, Y
	AND #&B5
	STA FX_address_row1+0, X
	LDA fx_table + 2, Y
	AND #&B5
	STA FX_address_row2+0, X
	LDA fx_table + 1, Y
	AND #&B5
	STA FX_address_row3+0, X
	LDA fx_table + 0, Y
	AND #&B5
	STA FX_address_row4+0, X
	\\ advance to next column
	INX
	TXA
	CMP #FX_num_freqs
ENDIF

	BNE fx_column_loop

	PLA:BEQ skip_beat_bars

	\\ Render the channel beat bars
	LDA #0
	LDX #FX_ch0_x
	JSR draw_beat_bar
	LDA #1
	LDX #FX_ch1_x
	JSR draw_beat_bar
	LDA #2
	LDX #FX_ch2_x
	JSR draw_beat_bar
	LDA #3
	LDX #FX_ch3_x
	JSR draw_beat_bar

	.skip_beat_bars
	
	\\ Let VU meter values fall to zero
	LDY #(FX_num_freqs) - 1
	.loop
	LDA freq_array,Y
	BEQ zero
	SEC
	SBC #1
	STA freq_array,Y
	.zero
	DEY
	BPL loop
	
	\\ Beat bars decay 2x faster
	LDY #(FX_num_channels) - 1
	.loop2
	LDA chan_array,Y
	BEQ zero2
	SEC
	SBC #1
	STA chan_array,Y
	BEQ zero2
	SEC
	SBC #1
	STA chan_array,Y	
	.zero2
	DEY
	BPL loop2
	
	
	.return
	RTS
}


\ ******************************************************************
\ *	Tracker scrolling display
\ ******************************************************************

.write_decimal_at		; A = number, X,Y = location on MODE 7 screen
{
	PHA
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	TXA:TAY

	\\ Count hundreds
	PLA
	LDX #0
	.loop_100
	CMP #100
	BCC done_100
	SEC
	SBC #100
	INX
	JMP loop_100
	.done_100
	PHA

	\\ Write hundreds
	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY
	
	\\ Count tens
	PLA
	LDX #0
	.loop_10
	CMP #10
	BCC done_10
	SEC
	SBC #10
	INX
	JMP loop_10
	.done_10
	PHA

	\\ Write tens
	CLC
	TXA
	ADC #'0'
	STA (writeptr),Y
	INY

	\\ Write units
	CLC
	PLA
	ADC #'0'
	STA (writeptr),Y

	.return
	RTS
}

.mode7_copy_line				; copy line X to line Y
{
	\\ From line X
	LDA mode7_row_addr_LO,X
	STA readptr
	LDA mode7_row_addr_HI,X
	STA readptr+1

	\\ To line Y
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	LDY #0
	.loop
	LDA (readptr),Y
	STA (writeptr),Y
	INY
	CPY #MODE7_char_width
	BNE loop

	.return
	RTS
}

.copy_channel_fields			; copy channel fields only from line X to line Y
{
	\\ From line X
	LDA mode7_row_addr_LO,X
	STA readptr
	LDA mode7_row_addr_HI,X
	STA readptr+1

	\\ To line Y
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	\\ Tracker line number field
	LDY #TRACKER_lineno_field_xpos

	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 3 field
	LDY #TRACKER_ch3_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 2 field
	LDY #TRACKER_ch2_field_xpos

	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Channel 1 field
	LDY #TRACKER_ch1_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	\\ Noise channel field
	LDY #TRACKER_noise_field_xpos
	
	\\ Copy 4 bytes
	LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y
	INY: LDA (readptr),Y: STA (writeptr),Y

	.return
	RTS
}

.write_note_name
{
	LDA note_name_table_0,X
	STA (writeptr),Y
	INY

	LDA note_name_table_1,X
	STA (writeptr),Y
	INY

	LDA note_name_table_2,X
	STA (writeptr),Y
	INY

	.return
	RTS
}

.write_note_blank
{
	LDA #'-'
	STA (writeptr),Y
	INY
	STA (writeptr),Y
	INY
	STA (writeptr),Y
	INY

	.return
	RTS
}

MACRO WRITE_VOL_CHAR
{
	LDA hex_to_ascii, X
	STA (writeptr),Y
}
ENDMACRO

MACRO WRITE_VOL_BLANK
{
	LDA #'-'
	STA (writeptr),Y
}
ENDMACRO

.poll_tracker
{
	\\ Temporary scroll values up - don't need to calc write addresses when locations fixed
	LDX #TRACKER_top_line_ypos + 1
	LDY #TRACKER_top_line_ypos
	JSR copy_channel_fields

	LDX #TRACKER_top_line_ypos + 2
	LDY #TRACKER_top_line_ypos + 1
	JSR copy_channel_fields

	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_top_line_ypos + 2
	JSR copy_channel_fields

	\\ **Should be writing our fields to active line!**

	LDX #TRACKER_bottom_line_ypos - 2
	LDY #TRACKER_active_line_ypos
	JSR copy_channel_fields

	LDX #TRACKER_bottom_line_ypos - 1
	LDY #TRACKER_bottom_line_ypos - 2
	JSR copy_channel_fields

	LDX #TRACKER_bottom_line_ypos
	LDY #TRACKER_bottom_line_ypos - 1
	JSR copy_channel_fields

	\\ **Instead writing our live data into bottom line!**
	\\ Write our current line number as decimal

	LDA player_counter
	LDX #TRACKER_lineno_field_xpos + 1			; +1 because leading 0 is constant
	LDY #TRACKER_bottom_line_ypos
	JSR write_decimal_at

	\\ Can reuse writeptr here - pointing to start of line we're writing!
	\\ Write channel values into fields - DO THIS BETTER?

	.write_field_channel3
	{
		LDY #12
		LDA player_reg_bits
		AND #SN_BIT_TONE3_FREQ		; channel 3 tone
		BEQ no_ch3_tone

		LDX player_reg_vals + SN_REG_TONE3_FREQ
		JSR write_note_name
		BNE try_ch3_vol		; OK because last instruction is INY

		.no_ch3_tone
		JSR write_note_blank

		.try_ch3_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE3_VOL		; channel 3 vol
		BEQ no_ch3_vol

		LDX player_reg_vals + SN_REG_TONE3_VOL
		WRITE_VOL_CHAR
		BNE done_ch3		; OK because A is char therefore not zero

		.no_ch3_vol
		WRITE_VOL_BLANK

		.done_ch3
	}

	.write_field_channel2
	{
		LDY #19
		LDA player_reg_bits
		AND #SN_BIT_TONE2_FREQ		; channel 2 tone
		BEQ no_ch2_tone

		LDX player_reg_vals + SN_REG_TONE2_FREQ
		JSR write_note_name
		BNE try_ch2_vol		; OK because last instruction is INY

		.no_ch2_tone
		JSR write_note_blank

		.try_ch2_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE2_VOL		; channel 2 vol
		BEQ no_ch2_vol

		LDX player_reg_vals + SN_REG_TONE2_VOL
		WRITE_VOL_CHAR
		BNE done_ch2		; OK because A is char therefore not zero

		.no_ch2_vol
		WRITE_VOL_BLANK

		.done_ch2
	}

	.write_field_channel1
	{
		LDY #26
		LDA player_reg_bits
		AND #SN_BIT_TONE1_FREQ		; channel 1 tone
		BEQ no_ch1_tone

		LDX player_reg_vals + SN_REG_TONE1_FREQ
		JSR write_note_name
		BNE try_ch1_vol		; OK because last instruction is INY

		.no_ch1_tone
		JSR write_note_blank

		.try_ch1_vol
		LDA player_reg_bits
		AND #SN_BIT_TONE1_VOL		; channel 1 vol
		BEQ no_ch1_vol

		LDX player_reg_vals + SN_REG_TONE1_VOL
		WRITE_VOL_CHAR
		BNE done_ch1		; OK because A is char therefore not zero

		.no_ch1_vol
		WRITE_VOL_BLANK

		.done_ch1
	}

	.write_field_noise
	{
		LDY #33
		LDA player_reg_bits
		AND #SN_BIT_NOISE_CTRL		; noise channel control
		BEQ no_noise_tone

		\\ Check noise control
		LDA player_reg_vals + SN_REG_NOISE_CTRL
		AND #SN_FB_MASK
		BEQ noise_periodic
		LDA #'W'					; White Noise
		EQUB &2C					; = BIT noise_periodic => skip next two bytes
		.noise_periodic
		LDA #'P'					; Periodic Noise
		STA (writeptr),Y
		INY

		LDA player_reg_vals + SN_REG_NOISE_CTRL
		AND #SN_NF_MASK
		ASL A						; *2
		TAX
		LDA noise_note_0,X			; noise_note = Lo,Me,Hi,T1	
		STA (writeptr),Y
		INY
		LDA noise_note_0+1,X		; 2nd char
		STA (writeptr),Y
		INY

		BNE try_noise_vol			; OK because last instruction is INY

		.no_noise_tone
		JSR write_note_blank

		.try_noise_vol
		LDA player_reg_bits
		AND #SN_BIT_NOISE_VOL		; noise channel vol
		BEQ no_noise_vol

		LDX player_reg_vals + SN_REG_NOISE_VOL
		WRITE_VOL_CHAR
		BNE done_noise				; OK because A is char therefore not zero

		.no_noise_vol
		WRITE_VOL_BLANK	

		.done_noise
	}

	\\ Duplicate line 17 to line 18 for double height
	LDX #TRACKER_active_line_ypos
	LDY #TRACKER_dupe_line_ypos
	JSR mode7_copy_line

	.return
	RTS
}


\ ******************************************************************
\ *	VGM music player
\ ******************************************************************

.init_player
{
	\\ Consume sample rate byte
	jsr get_decrunched_byte

	LDA #0
	STA player_ended
	STA player_last_reg
	STA player_reg_bits

	LDA #&FF
	STA player_counter

	.return
	RTS
}

.deinit_player
{
	\\ Zero volume on all channels
	LDA #&9F: JSR psg_strobe
	LDA #&BF: JSR psg_strobe
	LDA #&DF: JSR psg_strobe
	LDA #&FF: JSR psg_strobe
	
	.return
	RTS
}

.poll_player
{
	\\ Assume this is called every 20ms..
	LDA #0
	STA player_reg_bits

	LDA player_ended
	BNE _sample_end

	\\ Get next byte from the stream
	jsr get_decrunched_byte
	bcs _sample_end

	cmp #&ff
	beq _player_end

	\\ Byte is #data bytes to send to sound chip:
	TAY
	.sound_data_loop
	BEQ wait_20_ms
	TYA:PHA
	jsr get_decrunched_byte
	bcc not_sample_end
	PLA
	JMP _sample_end

	.not_sample_end
	JSR psg_decode
	JSR psg_strobe
	PLA:TAY:DEY
	JMP sound_data_loop
	
	.wait_20_ms
	INC player_counter				; indicate we have completed another frame of audio
	CLC
	RTS

	._player_end
	STA player_ended

	\\ Silence sound chip
	JSR deinit_player

	INC player_counter				; indicate we have completed one last frame of audio

	._sample_end
	SEC
	RTS
}

.psg_strobe
{
	sei					; **SELF-MODIFIED CODE**
	ldy #255
	sty $fe43
	
	sta $fe41
	lda #0
	sta $fe40
	nop
	nop
	nop
	nop
	nop
	nop
	lda #$08
	sta $fe40
	cli					; **SELF-MODIFIED CODE**
	RTS
}

PSG_STROBE_SEI_INSN = psg_strobe
PSG_STROBE_CLI_INSN = psg_strobe + 25

.psg_decode
{
	STA player_data
	AND #SN_FREQ_BYTE_MASK
	BEQ second_byte

	\\ First byte

	\\ Obtain register fields
	
	\\ Get register from bits 7,6,5
	LDA player_data
	AND #SN_REG_MASK
	LSR A:LSR A:LSR A:LSR A
	STA player_last_reg

	\\ Y is our register number
	TAY

	\\ Set bit field for each register used this frame
	LDA num_to_bit,Y				; look up bit for reg number
	ORA player_reg_bits				; mask in bit
	STA player_reg_bits

	\\ Is this tone or volume register?
	TYA
	AND #&01
	BEQ process_tone_data

	\\ Volume data
	LDA player_data
	AND #SN_VOL_MASK
	STA player_reg_vals,Y

	\\ Invert volume (0 = max 15 = off)
	SEC
	LDA #SN_VOL_MAX
	SBC player_reg_vals,Y
	STA player_reg_vals,Y
	JMP return

	\\ Frequency / tone data
	.process_tone_data
	CPY #SN_REG_NOISE_CTRL				; Y already register number
	BNE tone_channel

	\\ Noise channel
	LDA player_data
	AND #(SN_NF_MASK OR SN_FB_MASK)		; store noise freq data
	STA player_reg_vals,Y

	JMP trigger_beat

	.tone_channel
	LDA player_data
	AND #SN_FREQ_FIRST_BYTE_MASK		; F3 - F0
	LSR A: LSR A						; lose bottom 2 bits
	STA player_reg_vals,Y

	.trigger_beat
	\\ trigger the beat effect for this channel
	TYA:LSR A:TAY						; channel is register / 2
	LDA #9
	STA chan_array, Y

	JMP return

	.second_byte
	LDA player_data
	AND #SN_FREQ_SECOND_BYTE_MASK		; F9 - F4
	STA tmp_var
	ASL A: ASL A						; put 6 bits to top of byte
	LDY player_last_reg
	ORA player_reg_vals,Y				; combine with bottom 2 bits
	STA player_reg_vals,Y

	\\ trigger the beat effect for this channel
; technically correct, but better visuals without this.
;	TYA:LSR A:TAY						; channel is register / 2
;	LDA #9
;	STA chan_array, Y

	LDA tmp_var
IF FX_num_freqs == 16
	\\ 16 frequency bars, so use top 4 bits
	LSR A : LSR A
ELSE
	\\ 32 frequency bars, so use top 5 bits
	LSR A
ENDIF
	
	\\ clamp final frequency to array range and invert 
	AND #FX_num_freqs-1
	STA tmp_var
	LDA #FX_num_freqs-1
	SEC
	SBC tmp_var
	TAX
	LDA #15
	STA freq_array,X

	.return
	LDA player_data
	RTS
}


\ ******************************************************************
\ *	Event Vector Routines
\ ******************************************************************

.start_eventv				; new event handler in X,Y
{
	\\ Remove interrupt instructions
	lda #NOP_OP
	sta PSG_STROBE_SEI_INSN
	sta PSG_STROBE_CLI_INSN
	
	\\ Set new Event handler
	sei
	LDA EVENTV
	STA old_eventv
	LDA EVENTV+1
	STA old_eventv+1

	stx EVENTV
	sty EVENTV+1
	cli
	
	\\ Enable VSYNC event.
	lda #14
	ldx #4
	jsr osbyte
	rts
}
	
.stop_eventv
{
	\\ Disable VSYNC event.
	lda #13
	ldx #4
	jsr osbyte

	\\ Reset old Event handler
	SEI
	LDA old_eventv
	STA EVENTV
	LDA old_eventv+1
	STA EVENTV+1
	CLI 

	\\ Insert interrupt instructions back
	lda #SEI_OP
	sta PSG_STROBE_SEI_INSN
	lda #CLI_OP
	sta PSG_STROBE_CLI_INSN
	rts
}


\ ******************************************************************
\ *	Debug helpers
\ ******************************************************************

IF _DEBUG
.debug_print_A				; trashes X
{
	PHA:PHA
	LSR A:LSR A:LSR A:LSR A
	TAX
	LDA hex_to_ascii,X
	JSR oswrch
	PLA
	AND #&0F
	TAX
	LDA hex_to_ascii,X
	JSR oswrch
	LDA #32
	JSR oswrch
	PLA
	RTS
}
ENDIF


\ ******************************************************************
\ *	Exomiser (decompression library)
\ ******************************************************************

; -------------------------------------------------------------------
; for this get_crunched_byte routine to work the crunched data has to be
; crunced using the -m <buffersize> and possibly the -l flags. Any other
; flag will just mess things up.
.get_crunched_byte
{
	INC _byte_lo
	bne _byte_skip_hi
	INC _byte_hi			; forward decrunch
._byte_skip_hi:

._byte
	lda VGM_stream_data-1	; **SELF-MODIFIED CODE**
_byte_lo = _byte + 1
_byte_hi = _byte + 2
	rts						; decrunch_file is called.
}
; VGM_end_of_data needs to point to the address just after the address
; of the last byte of crunched data.
; -------------------------------------------------------------------

EXO_crunch_byte_lo = get_crunched_byte + 9
EXO_crunch_byte_hi = get_crunched_byte + 10

; -------------------------------------------------------------------
; jsr this label to init the decruncher, it will init used zeropage
; zero page locations and the decrunch tables
; no constraints on register content, however the
; decimal flag has to be #0 (it almost always is, otherwise do a cld)
; -------------------------------------------------------------------
.init_decruncher				; pass in address of (crunched data-1) in X,Y
{
	STX EXO_crunch_byte_lo
	STY EXO_crunch_byte_hi

	jsr get_crunched_byte
	sta EXO_zp_bitbuf

	ldx #0
	stx EXO_zp_dest_lo
	stx EXO_zp_dest_hi
	stx EXO_zp_len_lo
	stx EXO_zp_len_hi
	ldy #0
; -------------------------------------------------------------------
; calculate tables (49 bytes)
; x and y must be #0 when entering
;
._init_nextone
	inx
	tya
	and #$0f
	beq _init_shortcut		; starta på ny sekvens

	txa			; this clears reg a
	lsr a			; and sets the carry flag
	ldx EXO_zp_bits_lo
._init_rolle
	rol a
	rol EXO_zp_bits_hi
	dex
	bpl _init_rolle		; c = 0 after this (rol EXO_zp_bits_hi)

	adc tabl_lo-1,y
	tax

	lda EXO_zp_bits_hi
	adc tabl_hi-1,y
._init_shortcut
	sta tabl_hi,y
	txa
	sta tabl_lo,y

	ldx #4
	jsr _bit_get_bits		; clears x-reg.
	sta tabl_bi,y
	iny
	cpy #52
	bne _init_nextone
}
\\ Fall through!	

._do_exit
	rts

; -------------------------------------------------------------------
; decrunch one byte
;
.get_decrunched_byte
{
	ldy EXO_zp_len_lo
	bne _do_sequence
	ldx EXO_zp_len_hi
	bne _do_sequence2

	jsr _bit_get_bit1
	beq _get_sequence
; -------------------------------------------------------------------
; literal handling (13 bytes)
;
	jsr get_crunched_byte
	bcc _do_literal
; -------------------------------------------------------------------
; count zero bits + 1 to get length table index (10 bytes)
; y = x = 0 when entering
;
._get_sequence
._seq_next1
	iny
	jsr _bit_get_bit1
	beq _seq_next1
	cpy #$11
	bcs _do_exit
; -------------------------------------------------------------------
; calulate length of sequence (zp_len) (17 bytes)
;
	ldx tabl_bi - 1,y
	jsr _bit_get_bits
	adc tabl_lo - 1,y
	sta EXO_zp_len_lo
	lda EXO_zp_bits_hi
	adc tabl_hi - 1,y
	sta EXO_zp_len_hi
; -------------------------------------------------------------------
; here we decide what offset table to use (20 bytes)
; x is 0 here
;
	bne _seq_nots123
	ldy EXO_zp_len_lo
	cpy #$04
	bcc _seq_size123
._seq_nots123
	ldy #$03
._seq_size123
	ldx tabl_bit - 1,y
	jsr _bit_get_bits
	adc tabl_off - 1,y
	tay
; -------------------------------------------------------------------
; calulate absolute offset (zp_src) (27 bytes)
;
	ldx tabl_bi,y
	jsr _bit_get_bits;
	adc tabl_lo,y
	bcc _seq_skipcarry
	inc EXO_zp_bits_hi
	clc
._seq_skipcarry
	adc EXO_zp_dest_lo
	sta EXO_zp_src_lo
	lda EXO_zp_bits_hi
	adc tabl_hi,y
	adc EXO_zp_dest_hi
; -------------------------------------------------------------------
	cmp #HI(EXO_buffer_len)
	bcc _seq_offset_ok
	sbc #HI(EXO_buffer_len)
	clc
; -------------------------------------------------------------------
._seq_offset_ok
	sta EXO_zp_src_hi
	adc #HI(EXO_buffer_start)
	sta EXO_zp_src_bi
._do_sequence
	ldy #0
._do_sequence2
	ldx EXO_zp_len_lo
	bne _seq_len_dec_lo
	dec EXO_zp_len_hi
._seq_len_dec_lo
	dec EXO_zp_len_lo
; -------------------------------------------------------------------
	ldx EXO_zp_src_lo
	bne _seq_src_dec_lo
	ldx EXO_zp_src_hi
	bne _seq_src_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_src_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_src_bi
; -------------------------------------------------------------------
._seq_src_dec_hi
	dec EXO_zp_src_hi
	dec EXO_zp_src_bi
._seq_src_dec_lo
	dec EXO_zp_src_lo
; -------------------------------------------------------------------
	lda (EXO_zp_src_lo),y
; -------------------------------------------------------------------
._do_literal
	ldx EXO_zp_dest_lo
	bne _seq_dest_dec_lo
	ldx EXO_zp_dest_hi
	bne _seq_dest_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_dest_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_dest_bi
; -------------------------------------------------------------------
._seq_dest_dec_hi
	dec EXO_zp_dest_hi
	dec EXO_zp_dest_bi
._seq_dest_dec_lo
	dec EXO_zp_dest_lo
; -------------------------------------------------------------------
	sta (EXO_zp_dest_lo),y
	clc
	rts
}

; -------------------------------------------------------------------
; two small static tables (6 bytes)
;
.tabl_bit
{
	EQUB 2,4,4
}
.tabl_off
{
	EQUB 48,32,16
}

; -------------------------------------------------------------------
; get x + 1 bits (1 byte)
;
._bit_get_bit1
	inx
; -------------------------------------------------------------------
; get bits (31 bytes)
;
; args:
;   x = number of bits to get
; returns:
;   a = #bits_lo
;   x = #0
;   c = 0
;   EXO_zp_bits_lo = #bits_lo
;   EXO_zp_bits_hi = #bits_hi
; notes:
;   y is untouched
;   other status bits are set to (a == #0)
; -------------------------------------------------------------------
._bit_get_bits
{
	lda #$00
	sta EXO_zp_bits_lo
	sta EXO_zp_bits_hi
	cpx #$01
	bcc _bit_bits_done
	lda EXO_zp_bitbuf
._bit_bits_next
	lsr a
	bne _bit_ok
	jsr get_crunched_byte
	ror a
._bit_ok
	rol EXO_zp_bits_lo
	rol EXO_zp_bits_hi
	dex
	bne _bit_bits_next
	sta EXO_zp_bitbuf
	lda EXO_zp_bits_lo
._bit_bits_done
	rts
}
; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

; -------------------------------------------------------------------
; this 156 byte table area may be relocated. It may also be clobbered
; by other data between decrunches.
; -------------------------------------------------------------------
.decrunch_table
.tabl_bi  SKIP 156
tabl_lo = decrunch_table + 52
tabl_hi = decrunch_table + 104

; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

\ ******************************************************************
\ *	Stored data
\ ******************************************************************

.loading_table			; update NUM_vgm_files if this changes
EQUB LO(vgm_filename_1): EQUB HI(vgm_filename_1)
EQUB LO(vgm_filename_2): EQUB HI(vgm_filename_2)
EQUB LO(vgm_filename_3): EQUB HI(vgm_filename_3)
EQUB LO(vgm_filename_4): EQUB HI(vgm_filename_4)

.vgm_filename_1			EQUS "master", 13
.vgm_filename_2			EQUS "except", 13
.vgm_filename_3			EQUS "fluid", 13
.vgm_filename_4			EQUS "ice", 13

.menu_table
EQUB LO(menu_entry_1): EQUB HI(menu_entry_1)
EQUB LO(menu_entry_2): EQUB HI(menu_entry_2)
EQUB LO(menu_entry_3): EQUB HI(menu_entry_3)
EQUB LO(menu_entry_4): EQUB HI(menu_entry_4)
EQUB LO(menu_entry_5): EQUB HI(menu_entry_5)

.menu_entry_1			EQUS "1. Master.vgm                     "
.menu_entry_2			EQUS "2. Except.vgm                     "
.menu_entry_3			EQUS "3. Fluid.vgm                      "
.menu_entry_4			EQUS "4. Ice.vgm                        "
.menu_entry_5			EQUS "Exit                              "

\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

\\ Start address of each row in MODE 7 - wasteful but helpful
.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

\\ Lookup byte address for a given teletexel y coordinate - wasteful but fast
.mode7_texel_y_to_row_addr_LO
FOR n, 0, MODE7_texel_height-1, 1
	EQUB LO(MODE7_base_addr + ((n DIV 3) * MODE7_char_width) + 2)
NEXT

.mode7_texel_y_to_row_addr_HI
FOR n, 0, MODE7_texel_height-1, 1
	EQUB HI(MODE7_base_addr + ((n DIV 3) * MODE7_char_width) + 2)
NEXT

\\ Lookup bit mask for a given teletexel y coordinate - wasteful but fast
.mode7_texel_lookup_x_even
FOR n, 0, MODE7_texel_height-1, 1
	EQUB 1 << ((n % 3) * 2)
NEXT

.mode7_texel_lookup_x_odd
FOR n, 0, MODE7_texel_height-1, 1
	IF (n % 3) = 0
		EQUB 2
	ELIF (n % 3) = 1
		EQUB 8
	ELSE
		EQUB 64			; stupid teletext spec
	ENDIF
NEXT

\\ 16 Arrangements of 5 teletext character bytes to render a vertical equalizer bar
.fx_table
EQUB 160, 160, 160, 160, 160
EQUB 160+80, 160, 160, 160, 160
EQUB 160+92, 160, 160, 160, 160
EQUB 160+95, 160, 160, 160, 160
EQUB 160+95, 160+80, 160, 160, 160
EQUB 160+95, 160+92, 160, 160, 160
EQUB 160+95, 160+95, 160, 160, 160
EQUB 160+95, 160+95, 160+80, 160, 160
EQUB 160+95, 160+95, 160+92, 160, 160
EQUB 160+95, 160+95, 160+95, 160, 160
EQUB 160+95, 160+95, 160+95, 160+80, 160
EQUB 160+95, 160+95, 160+95, 160+92, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160+80
EQUB 160+95, 160+95, 160+95, 160+95, 160+92
EQUB 160+95, 160+95, 160+95, 160+95, 160+95
EQUB 160+95, 160+95, 160+95, 160+95, 160+95	; last row copied to enable fixed bar effect

.num_to_bit				; look up bit N
EQUB &01, &02, &04, &08, &10, &20, &40, &80

.noise_note_0 EQUS "Lo"
.noise_note_1 EQUS "Md"
.noise_note_2 EQUS "Hi"
.noise_note_3 EQUS "T1"

.hex_to_ascii			; for volume print
EQUS "0123456789abcdef"

\\ Note name lookup table, index using upper 8 bits of a 10-bit tone value.
\\ Not mega accurate, but fast, and good enough for a reasonably convincing visual 
ALIGN &100
.note_name_table_0 EQUS "AAAAGECAFEDCAGGFEDDCCCAGGGFFFEDDDDCCCCAAGGGGGFFFFFFEEEDDDDDDCCCCCCCCAAAAGGGGGGGGFFFFFFFFFFEEEEEDDDDDDDDDDDDCCCCCCCCCCCCCBBBBBBBAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGFFFFFFFFFFFFFFFFFFFEEEEEEEEEEEDDDDDDDDDDDDDDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBAA"
;note_name_table_1 EQUS "----#-#-#--#-#---#-#---#--#---##--##----###--###------###---####--------####----#####----------######------######--------------########--------########---------#########---------------------###########------------#############----------------------------##"
\\ Quirk of MODE 7: ASCII 35='#' but in gfx mode 35+128='£' so need to use ASCII 95='_' so in gfx mode 95+128='#'
.note_name_table_1 EQUS "----_-_-_--_-_---_-_---_--_---__--__----___--___------___---____--------____----_____----------______------______--------------________--------________---------_________---------------------___________------------_____________----------------------------__"
.note_name_table_2 EQUS "9999999888887777777777666666666666666655555555555555555555555555555544444444444444444444444444444444444444444444444444443333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333322222222222222222"


\\ Need to put this last as I don't know how to undo the character map!
\\ Map character ASCII values to the byte offset into our MODE 7 font
\\ This is "cunning" but only works because the font has fewer than 256/6 (42) glyphs..

MAPCHAR 'A', 1
MAPCHAR 'B', 4
MAPCHAR 'C', 7
MAPCHAR 'D', 10
MAPCHAR 'E', 13
MAPCHAR 'F', 16
MAPCHAR 'G', 19
MAPCHAR 'H', 22
MAPCHAR 'I', 25
MAPCHAR 'J', 28
MAPCHAR 'K', 31
MAPCHAR 'L', 34
MAPCHAR 'M', 37

MAPCHAR 'a', 1
MAPCHAR 'b', 4
MAPCHAR 'c', 7
MAPCHAR 'd', 10
MAPCHAR 'e', 13
MAPCHAR 'f', 16
MAPCHAR 'g', 19
MAPCHAR 'h', 22
MAPCHAR 'i', 25
MAPCHAR 'j', 28
MAPCHAR 'k', 31
MAPCHAR 'l', 34
MAPCHAR 'm', 37

MAPCHAR 'N', 81
MAPCHAR 'O', 84
MAPCHAR 'P', 87
MAPCHAR 'Q', 90
MAPCHAR 'R', 93
MAPCHAR 'S', 96
MAPCHAR 'T', 99
MAPCHAR 'U', 102
MAPCHAR 'V', 105
MAPCHAR 'W', 108
MAPCHAR 'X', 111
MAPCHAR 'Y', 114
MAPCHAR 'Z', 117

MAPCHAR 'n', 81
MAPCHAR 'o', 84
MAPCHAR 'p', 87
MAPCHAR 'q', 90
MAPCHAR 'r', 93
MAPCHAR 's', 96
MAPCHAR 't', 99
MAPCHAR 'u', 102
MAPCHAR 'v', 105
MAPCHAR 'w', 108
MAPCHAR 'x', 111
MAPCHAR 'y', 114
MAPCHAR 'z', 117

MAPCHAR '0', 161
MAPCHAR '1', 164
MAPCHAR '2', 167
MAPCHAR '3', 170
MAPCHAR '4', 173
MAPCHAR '5', 176
MAPCHAR '6', 179
MAPCHAR '7', 182
MAPCHAR '8', 185
MAPCHAR '9', 188
MAPCHAR '?', 191
MAPCHAR '!', 194
MAPCHAR '.', 197

MAPCHAR ' ', 241

\\ Scrolltext messages stored as font glyph byte offsets

.demo_message
EQUS "BeebTracker scrolltext in the right place and now scrolled one pixel per frame. Looks pretty smooth! 0123456789?!. ", 0

.load_message
EQUS "Loading... ", 0

\\ ** ANY EQUS LINES AFTER THIS POINT WILL STILL CONTAIN REMAPPED CHARACTERS ** \\


\ ******************************************************************
\ *	MODE 7 screen data
\ ******************************************************************

.mode7_screen_data
INCBIN "screen3.mode7"

MENU_original_src_addr = mode7_screen_data + MENU_overlay_ypos * MODE7_char_width

.mode7_font_data				; we use 16/25 lines of this screen
INCBIN "font_5x5_shifted.mode7"

mode7_font_data_shifted = mode7_font_data + 8 * 40

.mode7_menu_data
INCBIN "menu_overlay.mode7"		; ditto, we only use ~8/25 lines of this screen

MENU_overlay_src_addr = mode7_menu_data + MENU_overlay_ypos * MODE7_char_width

\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************

.end


\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************

\\ Frequency array for vu-meter effect, plus beat bars for 4 channels
\\ These two must be contiguous in memory
.freq_array				SKIP FX_num_freqs
.chan_array				SKIP FX_num_channels
.player_reg_vals		SKIP SN_REG_MAX		; data values passed to each channel during audio playback (4x channels x pitch + volume)

\\ Params block for osfile command
.osfile_params			SKIP 18

\\ Exomiser unpack buffer (must be page aligned)
ALIGN &100
.EXO_buffer_start		SKIP EXO_buffer_len
.EXO_buffer_end


\ ******************************************************************
\ *	EXO VGM data file
\ * This must be compressed using the following flags:
\ * exomizer.exe raw -c -m 1024 <file.raw> -o <file.exo>
\ ******************************************************************

ALIGN &100
.VGM_stream_data
\\ Now loaded at run-time so don't know end of data!
.VGM_end_of_data


\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "BeebTrk", start, end
PUTFILE "fluid_beeb_50.raw.exo", "fluid", 0
PUTFILE "ice_opt_beeb_50_raw.exo", "ice", 0
PUTFILE "exception_beeb.raw.exo", "except", 0
PUTFILE "master_beeb.raw.exo", "master", 0

IF _DEBUG			; only needed for debug purposes
PUTFILE "screen3.mode7", "screen", &7C00
PUTFILE "font_5x5.mode7", "font", &7C00
PUTFILE "font_5x5_shifted.mode7", "font2", &7C00
PUTFILE "menu_overlay.mode7", "menu", &7C00
ENDIF