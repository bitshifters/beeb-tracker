\ ******************************************************************
\ * Beeb Tracker
\ * Music player & visualiser in MODE 7
\ * Kieran Connell & Simon Morris
\ * Demo team name TBD! :)
\ ******************************************************************


\ ******************************************************************
\ *	Define OS entries (could be INCLUDE bbc_os.h)
\ ******************************************************************

osfile = &FFDD
oswrch = &FFEE
osasci = &FFE3
osbyte = &FFF4
osword = &FFF1
EVENTV = &0220

INKEY_esc = 112
INKEY_q = 16

SEI_OP = $78
CLI_OP = $58
NOP_OP = $ea


\ ******************************************************************
\ *	Define debug flags
\ ******************************************************************

_DEBUG = TRUE

\ ******************************************************************
\ *	Define macros
\ ******************************************************************

MACRO SN_WRITE_ENABLE
	LDX #&00: STX &FE40			; R0=Output Register "B" (write) (write 1 into bit 0 - write to sound chip)
	NOP:NOP:NOP:NOP:NOP:NOP		; wait 8us (following LDX instruction takes 2 cycles)
	LDX #&08: STX &FE40			; set sound chip write pin high
ENDMACRO


\ ******************************************************************
\ *	Define global constants
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_buffer_len = 1024

\\ VGM
VGM_write_sound_data = &50
VGM_wait_50_Hz = &63
VGM_wait_60_Hz = &62
VGM_wait_N_samples = &61
VGM_end_of_stream = &66

VGM_sample_rate = 44100
VGM_50HZ_samples = (VGM_sample_rate / 50)
VGM_60HZ_samples = (VGM_sample_rate / 60)
VGM_100Hz_samples = (VGM_sample_rate / 100)
VGM_POLL_samples = VGM_50HZ_samples

\\ MODE 7
MODE7_base_addr = &7C00
MODE7_char_width = 40
MODE7_char_height = 25
MODE7_texel_width = (MODE7_char_width - 2) * 2
MODE7_texel_height = MODE7_char_height * 3

MODE7_alpha_black = 128
MODE7_graphic_black = 144
MODE7_contiguous = 153
MODE7_separated = 154

\\ FONT
FONT_first_glyph = ' '
FONT_last_glyph = '~'
FONT_num_glyphs = FONT_last_glyph - FONT_first_glyph + 1


\ ******************************************************************
\ *	Define app constants
\ ******************************************************************

NUM_vgm_files = 4				; size of our file table

FX_num_freqs = 16				; can be 16 or 32
FX_draw_at_row = 12				; bottom of vu meter (row)
FX_draw_end_x = 68				; right of vu meter (pixel)

FX_chr_x = 4
FX_chr_y = 8
FX_chr_w = 32
FX_chr_h = 5
FX_address = &7C00 + FX_chr_y*40 + FX_chr_x
FX_address_row0 = FX_address
FX_address_row1 = FX_address_row0 + 40
FX_address_row2 = FX_address_row1 + 40
FX_address_row3 = FX_address_row2 + 40
FX_address_row4 = FX_address_row3 + 40

\ ******************************************************************
\ *	Define fast (zero page) runtime variables
\ ******************************************************************

\\ EXOMISER (compression library)
EXO_zp_src_hi = $70
EXO_zp_src_lo = EXO_zp_src_hi + 1
EXO_zp_src_bi = EXO_zp_src_hi + 2
EXO_zp_bitbuf = EXO_zp_src_hi + 3

EXO_zp_len_lo  = $74
EXO_zp_len_hi  = EXO_zp_len_lo + 1

EXO_zp_bits_lo = $76
EXO_zp_bits_hi = EXO_zp_bits_lo + 1

EXO_zp_dest_hi = $78
EXO_zp_dest_lo = EXO_zp_dest_hi + 1	; dest addr lo
EXO_zp_dest_bi = EXO_zp_dest_hi + 2	; dest addr hi

\\ Our own app variables
ORG &7B
GUARD &9F

\\ Player vars
.player_ended			SKIP 1		; non-zero when player has reached end of tune
.player_data			SKIP 1		; temporary variable when decoding sound data - must be separate as player running on events
.player_channel_vals	SKIP 8		; data values passed to each channel during audio playback (4x channels x pitch + volume)
.player_last_channel	SKIP 1		; last channel (register) refered to by the VGM sound data

\\ Temporary vars
.tmp_var				; SHARED	; free for any function to use but not preserved across subroutines
.tmp_erase				SKIP 1		; used when erasing rows or pixels

.tmp_col_mask			; SHARED	; scr_init only - used to rotate font glyph data
.tmp_cur_col			; SHARED	; poll_scr only - current column into font
.tmp_fx_y				SKIP 1		; poll_fx only - current y value being plotted

.tmp_row_bit			; SHARED	; scr_init only - used to rotate font glyph data
.tmp_font_byte			SKIP 1		; poll_scr only - current byte of font data

.tmp_msg_idx			SKIP 1		; current index into scr_message - only used during poll_scr

\\ Generic vars
.writeptr				SKIP 2		; generic write ptr
.readptr				SKIP 2		; generic read ptr

\\ Scroll text vars
.scr_msg_idx			SKIP 1		; index into scr_message
.scr_col				SKIP 1		; current column in first character to be displayed
.scr_y					SKIP 1		; y coordinate of scroll text

\\ Loading state vars
.load_x					SKIP 1		; animated pixel x
.load_y					SKIP 1		; animated pixel y

\\ App state vars
.file_no				SKIP 1		; index into our file table

\\ System vars
.old_eventv				SKIP 2

\ ******************************************************************
\ *	Start address to be saved
\ ******************************************************************

ORG &1900	      					; code origin - assume standard BBC Micro
GUARD &7C00							; ensure code size doesn't hit start of screen memory

.start


\ ******************************************************************
\ *	Code entry
\ ******************************************************************

\ ******************************************************************
\ *	Main loop including high-level state machine
\ ******************************************************************

.main
{
\\ ***** System initialise ***** \\

	\\ Set MODE 7
	LDA #22: JSR oswrch
	LDA #7: JSR oswrch

	\\ Must be a simpler way to turn off cursor than this!!
	LDA #23: JSR oswrch
	LDA #1: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch
	LDA #0: JSR oswrch

	\\ Load first file in our list
	LDA #0
	STA file_no
	
\\ ***** Enter loading state ***** \\

	.enter_loading_state
	\\ Clear screen
	LDA #12: JSR oswrch
	JSR teletexel_init

	\\ Init scrolltext with loading message
	LDA #LO(load_message):LDX #HI(load_message)
	LDY #11:JSR init_scr

	\\ Start our event driven fx
	ldx #LO(load_eventv)
	ldy #HI(load_eventv)
	JSR start_eventv

	\\ Blocking file load
	JSR load_file_from_table
	PHA							; store return value

	\\ Kill our event driven fx
	JSR stop_eventv

	\\ Returned error?
	PLA
	BNE return

\\ ***** Enter demo state ***** \\

	\\ Initialise demo state
	JSR init_demo

	\\ Demo loop
	.demo_loop
	{
		\\ Check for Escape key
		LDA #121
		LDX #(INKEY_q EOR &80)
		JSR osbyte
		TXA
		BMI exit_demo

		\\ Wait for vsync
		LDA #19
		JSR osbyte

		\\ Poll our demo
		JSR poll_demo

		\\ Returns whether player has finished
		BEQ demo_loop

		.exit_demo

		\\ Deinitialise demo state
		JSR deinit_demo
	}

\\ ***** Trigger next load ***** \\

	\\ Increment file in table
	LDX file_no
	INX
	CPX #NUM_vgm_files
	BCC next_file
	LDX #0
	.next_file
	STX file_no

\\ ***** Exit demo state ***** \\

	JMP enter_loading_state

	\\ Exit cleanly (we hope)
	.return
	RTS
}


\ ******************************************************************
\ *	Demo state routines
\ ******************************************************************

.init_demo
{
	\\ Set load and store addresses
	\\ Is it really necessary to use self-modifying code here?!

	LDA #LO(mode7_screen_data)
	STA loop+1
	LDA #HI(mode7_screen_data)
	STA loop+2

	LDA #LO(MODE7_base_addr)
	STA loop+4
	LDA #HI(MODE7_base_addr)
	STA loop+5

	\\ Initialise MODE 7 screen
	LDY #0
	.loop
	LDA mode7_screen_data,Y				; **SELF-MODIFIED CODE**
	STA MODE7_base_addr,Y				; **SELF-MODIFIED CODE**

	INY
	BNE loop
	INC loop + 2						; increment read address hi byte
	INC loop + 5						; increment write address hi byte
	BPL loop							; until >= &8000

	\\ Initialise our effects
	JSR init_fx

	LDA #LO(demo_message): LDX #HI(demo_message)
	LDY #23: JSR init_scr				; top of scroller at Y

	\\ Initialise exomizer - must have some data ready to decrunch
	LDX #LO(VGM_stream_data - 1)
	LDY #HI(VGM_stream_data - 1)
	JSR init_decruncher

	\\ Initialise music player - consumes first crunched byte
	JSR	init_player

	\\ Hook up Event vector - starts player
	ldx #LO(demo_eventv)
	ldy #HI(demo_eventv)
	JSR start_eventv

	.return
	RTS
}

.poll_demo
{
	\\ Poll our VU effects
	JSR poll_fx

	\\ Update scrolltext
	JSR poll_scr

	\\ Poll the music player
	LDA player_ended

	.return
	RTS
}

.deinit_demo
{
	\\ Unhook Event vector - stops player
	JSR stop_eventv

	\\ Shutdown music player - silences all audio channels
	JSR deinit_player
	
	.return
	RTS
}

.demo_eventv
{
	php
	cmp #4
	bne not_vsync

	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

	\\ Poll the music player
	jsr poll_player

	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	File loading routines
\ ******************************************************************

.load_file_from_table			; flle_no = index into our table
{
	LDA file_no
	ASL A:TAX

	\\ Set osfile param block
	LDA loading_table,X
	STA osfile_params + 0
	LDA loading_table+1,X
	STA osfile_params + 1

	LDA #LO(VGM_stream_data)
	STA osfile_params + 2
	LDA #HI(VGM_stream_data)
	STA osfile_params + 3

	LDA #0
	STA osfile_params + 6

	\\ Issue osfile call
	LDX #LO(osfile_params)
	LDY #HI(osfile_params)
	LDA #&FF
	JSR osfile

	\\ Error?
	LDA #0						; should return whether error occurred
	.return
	RTS
}

.load_eventv
{
	php
	cmp #4
	beq vsync
	JMP not_vsync

	.vsync
	\\ Preserve registers
	pha:TXA:PHA:TYA:PHA

\\ ***** Loading FX ***** \\

\\ Must be cheap otherwise will callback will re-enter!

	\\ Remove old pixel
	LDX load_x
	LDY load_y
	JSR teletexel_erase

	\\ Update pixel pos - just move left to right, top to bottom
	LDX load_x
	LDY load_y
	INX:INX
	CPX #MODE7_texel_width
	BCC no_wrapx
	INY:INY
	CPY #MODE7_texel_height
	BCC no_wrapy
	LDY #0
	.no_wrapy
	STY load_y
	LDX #0
	.no_wrapx
	STX load_x
	
	\\ Draw new pixel
	JSR teletexel_plot

	\\ Poll scroll
	JSR poll_scr
	
	\\ Restore registers
	PLA:TAY:PLA:TAX:pla

	\\ Return
    .not_vsync
	plp
	rts
}


\ ******************************************************************
\ *	Teletexel / MODE 7 functions & helpers
\ ******************************************************************

.teletexel_init						; set blank screen
{
	LDX #MODE7_contiguous
	LDY #MODE7_char_height - 1

	.loop
	TYA:PHA
	LDA #MODE7_graphic_black + 7
	JSR teletexel_set_row_start
	PLA:TAY
	DEY
	BPL loop

	.return
	RTS
}

.teletexel_set_row_start			; set row Y to char A, X
{
	PHA
	LDA mode7_row_addr_LO,Y
	STA writeptr
	LDA mode7_row_addr_HI,Y
	STA writeptr+1

	LDY #0
	PLA
	STA (writeptr),Y
	TXA:INY
	STA (writeptr),Y

	.return
	RTS
}

.teletexel_erase_row				; row Y, start X, end A
{
	STA tmp_erase

	LDA mode7_row_addr_LO,Y
	STA loop+1
	LDA mode7_row_addr_HI,Y
	STA loop+2

	LDA #32
	.loop
	STA MODE7_base_addr,X			; **SELF-MODIFIED CODE**
	INX
	CPX tmp_erase
	BNE loop

	.return
	RTS	
}

MACRO TELETEXEL_CALC_WRITEPTR_AND_MASK				; preserves X destroys A & Y
{
	\\ Turn texel y into address of row
	LDA mode7_texel_y_to_row_addr_LO,Y				; 4c
	STA writeptr									; 3c
	LDA mode7_texel_y_to_row_addr_HI,Y				; 4c
	STA writeptr+1									; 3c

	\\ Add x character offset
	TXA												; 2c
	LSR A											; 2c
	BCS odd											; 3c

	\\ Even
	.even
	\\ We know carry is clear
	ADC writeptr									; 3c
	STA writeptr									; 3c
	BCC no_carry_even								; 3c
	INC writeptr+1									; 5c
	.no_carry_even
	LDA mode7_texel_lookup_x_even,Y					; 4c
	JMP plot_texel									; 3c

	\\ Odd
	.odd
	CLC												; 2c
	ADC writeptr									; 3c
	STA writeptr									; 3c
	BCC no_carry_odd								; 3c
	INC writeptr+1									; 5c
	.no_carry_odd
	LDA mode7_texel_lookup_x_odd,Y					; 4c

	.plot_texel
}													; odd = 41c even = 42c  (not including EOR & STA)
ENDMACRO

.teletexel_plot_eor									; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	LDY #0											; 2c - not needed on MASTER
	EOR (writeptr),Y								; 6c
	STA (writeptr),Y								; 6c

	.return
	RTS												
}													; total = 42+14 = 56c (not including RTS)

.teletexel_plot										; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	LDY #0											; 2c
	ORA (writeptr),Y								; 6c
	STA (writeptr),Y								; 6c

	.return
	RTS
}	

.teletexel_erase									; at X, Y
{
	TELETEXEL_CALC_WRITEPTR_AND_MASK

	EOR #&FF										; flip the bits
	STA tmp_erase
	LDY #0											; 2c
	LDA (writeptr),Y								; 6c
	AND tmp_erase
	STA (writeptr),Y								; 6c

	.return
	RTS
}	


\ ******************************************************************
\ *	Scrolltext code
\ * Redraws entire message each frame
\ * Only scrolls with byte precision, i.e. two pixels per frame
\ * This is too fast for a 5x5 pixel font
\ * TODO - rewrite to be single pixel scroll
\ ******************************************************************

.init_scr			; Y = y pos drawn at, A, X = address of message
{
	\\ Set address of message
	STA poll_scr_msg_addr_1+1
	STA poll_scr_msg_addr_2+1
	STX poll_scr_msg_addr_1+2
	STX poll_scr_msg_addr_2+2

	\\ Set address that scrolltext drawn to
	STY scr_y
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_1_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_1_addr+2
	INY
	LDA mode7_row_addr_LO,Y
	STA poll_scr_line_2_addr+1
	LDA mode7_row_addr_HI,Y
	STA poll_scr_line_2_addr+2

	LDA #0
	STA scr_msg_idx
	STA scr_col

	.return
	RTS
}

.poll_scr
\\{
	\\ Copy our temp variables for drawing
	LDA scr_col
	STA tmp_cur_col				; current column in font

	LDA scr_msg_idx
	STA tmp_msg_idx				; current index into message

	\\ Loop over characters in row
	LDX #2						; X char position - ignore first two
	.poll_scr_xloop

	LDY tmp_msg_idx
	.poll_scr_msg_addr_1
	LDA demo_message,Y			; actually contains the offset into font data
	BNE poll_scr_not_end_of_msg			; finish if zero

	LDY #0
	STY tmp_msg_idx
	BEQ poll_scr_msg_addr_1

	.poll_scr_not_end_of_msg
	\\ Work out which column we're on
	CLC
	ADC tmp_cur_col
	TAY

	\\ Draw a column of the font to the screen
	.poll_scr_draw_col
	LDA mode7_font_data,Y
	.poll_scr_line_1_addr
	STA &7C00,X

	LDA mode7_font_data + 40,Y
	.poll_scr_line_2_addr
	STA &7C28,X

	\\ Next screen column
	INX
	CPX #MODE7_char_width
	BEQ poll_scr_done

	\\ Next font column
	INY

	INC tmp_cur_col
	LDA tmp_cur_col
	CMP #3
	BNE poll_scr_draw_col

	\\ Done all columns
	LDY #0
	STY tmp_cur_col

	INC tmp_msg_idx				; next letter

	JMP poll_scr_xloop

	.poll_scr_done
	INC scr_col					; increment column for scroll
	LDA scr_col
	CMP #3
	BNE poll_scr_return					; 8 columns

	LDA #0
	STA scr_col					; reset column
	INC scr_msg_idx				; next char in scr_message

	LDY scr_msg_idx
	.poll_scr_msg_addr_2
	LDA demo_message,Y
	BNE poll_scr_return
	STA scr_msg_idx

	.poll_scr_return
	RTS
\\}


\ ******************************************************************
\ *	Graphic equaliser effect
\ ******************************************************************

.init_fx
{
	\\ Initialise the frequency array
	LDY #FX_num_freqs - 1
	LDA #0
	.loop
	STA freq_array,Y
	DEY
	BPL loop

	\\ hacky code to clear off the rogue bars left + right
	\\ better solution is to clean up screen layout
	LDX #0
	LDA #32
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	LDX #FX_chr_w+1
	STA FX_address_row0-1, X
	STA FX_address_row1-1, X
	STA FX_address_row2-1, X
	STA FX_address_row3-1, X
	STA FX_address_row4-1, X
	STA FX_address_row4-1, X
	
	.return
	RTS
}

.poll_fx
{

	\\ render the bar fx in 15 by 5 character columns
	LDX #0
	
	.fx_column_loop
	
	\\ get frequency level
	TXA
	
IF FX_num_freqs == 16
	LSR A
ENDIF

	TAY
	LDA freq_array, Y
	
	CLC
	ADC #1			; this hack forces levels to be a minimum of 1
					; which means there's always a green bar showing
					; fx_table lookup has a duplicated extra entry to prevent overread
	
	\\ mult*5 and lookup teletext bar graphic
	STA tmp_fx_y
	ASL A
	ASL A
	CLC
	ADC tmp_fx_y
	TAY
	
IF FX_num_freqs == 16
	\\ render the 5 byte bar column, 2 chrs per bar, 2nd bar has right hand column removed
	LDA fx_table + 4, Y
	STA FX_address_row0+0, X
	AND #&B5
	STA FX_address_row0+1, X
	LDA fx_table + 3, Y
	STA FX_address_row1+0, X
	AND #&B5
	STA FX_address_row1+1, X
	LDA fx_table + 2, Y
	STA FX_address_row2+0, X
	AND #&B5
	STA FX_address_row2+1, X
	LDA fx_table + 1, Y
	STA FX_address_row3+0, X
	AND #&B5
	STA FX_address_row3+1, X
	LDA fx_table + 0, Y
	STA FX_address_row4+0, X
	AND #&B5
	STA FX_address_row4+1, X
	\\ advance to next column
	INX
	INX
	TXA
	CMP #FX_num_freqs*2
ELSE
	\\ render the 5 byte bar column, 1 chr per bar
	LDA fx_table + 4, Y
	AND #&B5
	STA FX_address_row0+0, X
	LDA fx_table + 3, Y
	AND #&B5
	STA FX_address_row1+0, X
	LDA fx_table + 2, Y
	AND #&B5
	STA FX_address_row2+0, X
	LDA fx_table + 1, Y
	AND #&B5
	STA FX_address_row3+0, X
	LDA fx_table + 0, Y
	AND #&B5
	STA FX_address_row4+0, X
	\\ advance to next column
	INX
	TXA
	CMP #FX_num_freqs
ENDIF


	BNE fx_column_loop


	\\ Let values fall to zero
	LDY #FX_num_freqs - 1
	.loop
	LDA freq_array,Y
	BEQ zero
	SEC
	SBC #1
	STA freq_array,Y
	.zero
	DEY
	BPL loop
	
	.return
	RTS
}


\ ******************************************************************
\ *	VGM music player
\ ******************************************************************

.init_player
{
	\\ Consume sample rate byte
	jsr get_decrunched_byte

	LDA #0
	STA player_ended
	STA player_last_channel

	.return
	RTS
}

.deinit_player
{
	\\ Zero volume on all channels
	SEI
	LDX #&FF: STX &FE43					; R3=Data Direction Register "A" set to output
	LDA #&9F: STA &FE41					; tone 3 volume OFF
	SN_WRITE_ENABLE
	LDA #&BF: STA &FE41					; tone 2 volume OFF
	SN_WRITE_ENABLE
	LDA #&DF: STA &FE41					; tone 1 volume OFF
	SN_WRITE_ENABLE
	LDA #&FF: STA &FE41					; noise volume OFF
	SN_WRITE_ENABLE
	CLI
	
	.return
	RTS
}

.poll_player
{
	\\ Assume this is called every 20ms..

	\\ Get next byte from the stream
	jsr get_decrunched_byte
	bcs _sample_end

	cmp #&ff
	beq _player_end

	\\ Byte is #data bytes to send to sound chip:
	TAY
	.sound_data_loop
	BEQ wait_20_ms
	TYA:PHA
	jsr get_decrunched_byte
	bcc not_sample_end
	PLA
	JMP _sample_end

	.not_sample_end
	JSR psg_decode
	JSR psg_strobe
	PLA:TAY:DEY
	JMP sound_data_loop
	
	.wait_20_ms
	CLC
	RTS

	._player_end
	STA player_ended

	._sample_end
	SEC
	RTS
}

.psg_strobe
{
	sei					; **SELF-MODIFIED CODE**
	ldy #255
	sty $fe43
	
	sta $fe41
	lda #0
	sta $fe40
	nop
	nop
	nop
	nop
	nop
	nop
	lda #$08
	sta $fe40
	cli					; **SELF-MODIFIED CODE**
	RTS
}

PSG_STROBE_SEI_INSN = psg_strobe
PSG_STROBE_CLI_INSN = psg_strobe + 25

.psg_decode
{
	STA player_data
	AND #&80
	BEQ second_byte

	\\ First byte

	\\ Obtain register field
	LDA player_data
	AND #&70
	LSR A:LSR A:LSR A:LSR A
	STA player_last_channel

	TAY

	LDA player_data
	AND #&01
	BEQ freq

	\\ Volume
	LDA player_data
	AND #&0F
	STA player_channel_vals,Y

	SEC
	LDA #15
	SBC player_channel_vals,Y
	STA player_channel_vals,Y
	JMP return

	\\ Frequency
	.freq
	JMP return

	.second_byte
	LDA player_data
	AND #&3F
	LDY player_last_channel
	STA player_channel_vals,Y

	;CPY #4
	;BNE return
	
IF FX_num_freqs == 16
	\\ 16 frequency bars, so use top 4 bits
	LSR A : LSR A
ELSE
	\\ 32 frequency bars, so use top 5 bits
	LSR A
ENDIF
	
	\\ clamp final frequency to array range and invert 
	AND #FX_num_freqs-1
	STA tmp_var
	LDA #FX_num_freqs-1
	SEC
	SBC tmp_var
	TAX
	LDA #15
	STA freq_array,X

	.return
	LDA player_data
	RTS
}


\ ******************************************************************
\ *	Event Vector Routines
\ ******************************************************************

.start_eventv				; new event handler in X,Y
{
	\\ Remove interrupt instructions
	lda #NOP_OP
	sta PSG_STROBE_SEI_INSN
	sta PSG_STROBE_CLI_INSN
	
	\\ Set new Event handler
	sei
	LDA EVENTV
	STA old_eventv
	LDA EVENTV+1
	STA old_eventv+1

	stx EVENTV
	sty EVENTV+1
	cli
	
	\\ Enable VSYNC event.
	lda #14
	ldx #4
	jsr osbyte
	rts
}
	
.stop_eventv
{
	\\ Disable VSYNC event.
	lda #13
	ldx #4
	jsr osbyte

	\\ Reset old Event handler
	SEI
	LDA old_eventv
	STA EVENTV
	LDA old_eventv+1
	STA EVENTV+1
	CLI 

	\\ Insert interrupt instructions back
	lda #SEI_OP
	sta PSG_STROBE_SEI_INSN
	lda #CLI_OP
	sta PSG_STROBE_CLI_INSN
	rts
}


\ ******************************************************************
\ *	Debug helpers
\ ******************************************************************

IF _DEBUG
.debug_hexchars
EQUS "0123456789abcdef"

.debug_print_A				; trashes X
{
	PHA:PHA
	LSR A:LSR A:LSR A:LSR A
	TAX
	LDA debug_hexchars,X
	JSR oswrch
	PLA
	AND #&0F
	TAX
	LDA debug_hexchars,X
	JSR oswrch
	LDA #32
	JSR oswrch
	PLA
	RTS
}
ENDIF


\ ******************************************************************
\ *	Exomiser (decompression library)
\ ******************************************************************

; -------------------------------------------------------------------
; for this get_crunched_byte routine to work the crunched data has to be
; crunced using the -m <buffersize> and possibly the -l flags. Any other
; flag will just mess things up.
.get_crunched_byte
{
	INC _byte_lo
	bne _byte_skip_hi
	INC _byte_hi			; forward decrunch
._byte_skip_hi:

._byte
	lda VGM_stream_data-1	; **SELF-MODIFIED CODE**
_byte_lo = _byte + 1
_byte_hi = _byte + 2
	rts						; decrunch_file is called.
}
; VGM_end_of_data needs to point to the address just after the address
; of the last byte of crunched data.
; -------------------------------------------------------------------

EXO_crunch_byte_lo = get_crunched_byte + 9
EXO_crunch_byte_hi = get_crunched_byte + 10

; -------------------------------------------------------------------
; jsr this label to init the decruncher, it will init used zeropage
; zero page locations and the decrunch tables
; no constraints on register content, however the
; decimal flag has to be #0 (it almost always is, otherwise do a cld)
; -------------------------------------------------------------------
.init_decruncher				; pass in address of (crunched data-1) in X,Y
{
	STX EXO_crunch_byte_lo
	STY EXO_crunch_byte_hi

	jsr get_crunched_byte
	sta EXO_zp_bitbuf

	ldx #0
	stx EXO_zp_dest_lo
	stx EXO_zp_dest_hi
	stx EXO_zp_len_lo
	stx EXO_zp_len_hi
	ldy #0
; -------------------------------------------------------------------
; calculate tables (49 bytes)
; x and y must be #0 when entering
;
._init_nextone
	inx
	tya
	and #$0f
	beq _init_shortcut		; starta p√• ny sekvens

	txa			; this clears reg a
	lsr a			; and sets the carry flag
	ldx EXO_zp_bits_lo
._init_rolle
	rol a
	rol EXO_zp_bits_hi
	dex
	bpl _init_rolle		; c = 0 after this (rol EXO_zp_bits_hi)

	adc tabl_lo-1,y
	tax

	lda EXO_zp_bits_hi
	adc tabl_hi-1,y
._init_shortcut
	sta tabl_hi,y
	txa
	sta tabl_lo,y

	ldx #4
	jsr _bit_get_bits		; clears x-reg.
	sta tabl_bi,y
	iny
	cpy #52
	bne _init_nextone
}
\\ Fall through!	

._do_exit
	rts

; -------------------------------------------------------------------
; decrunch one byte
;
.get_decrunched_byte
{
	ldy EXO_zp_len_lo
	bne _do_sequence
	ldx EXO_zp_len_hi
	bne _do_sequence2

	jsr _bit_get_bit1
	beq _get_sequence
; -------------------------------------------------------------------
; literal handling (13 bytes)
;
	jsr get_crunched_byte
	bcc _do_literal
; -------------------------------------------------------------------
; count zero bits + 1 to get length table index (10 bytes)
; y = x = 0 when entering
;
._get_sequence
._seq_next1
	iny
	jsr _bit_get_bit1
	beq _seq_next1
	cpy #$11
	bcs _do_exit
; -------------------------------------------------------------------
; calulate length of sequence (zp_len) (17 bytes)
;
	ldx tabl_bi - 1,y
	jsr _bit_get_bits
	adc tabl_lo - 1,y
	sta EXO_zp_len_lo
	lda EXO_zp_bits_hi
	adc tabl_hi - 1,y
	sta EXO_zp_len_hi
; -------------------------------------------------------------------
; here we decide what offset table to use (20 bytes)
; x is 0 here
;
	bne _seq_nots123
	ldy EXO_zp_len_lo
	cpy #$04
	bcc _seq_size123
._seq_nots123
	ldy #$03
._seq_size123
	ldx tabl_bit - 1,y
	jsr _bit_get_bits
	adc tabl_off - 1,y
	tay
; -------------------------------------------------------------------
; calulate absolute offset (zp_src) (27 bytes)
;
	ldx tabl_bi,y
	jsr _bit_get_bits;
	adc tabl_lo,y
	bcc _seq_skipcarry
	inc EXO_zp_bits_hi
	clc
._seq_skipcarry
	adc EXO_zp_dest_lo
	sta EXO_zp_src_lo
	lda EXO_zp_bits_hi
	adc tabl_hi,y
	adc EXO_zp_dest_hi
; -------------------------------------------------------------------
	cmp #HI(EXO_buffer_len)
	bcc _seq_offset_ok
	sbc #HI(EXO_buffer_len)
	clc
; -------------------------------------------------------------------
._seq_offset_ok
	sta EXO_zp_src_hi
	adc #HI(EXO_buffer_start)
	sta EXO_zp_src_bi
._do_sequence
	ldy #0
._do_sequence2
	ldx EXO_zp_len_lo
	bne _seq_len_dec_lo
	dec EXO_zp_len_hi
._seq_len_dec_lo
	dec EXO_zp_len_lo
; -------------------------------------------------------------------
	ldx EXO_zp_src_lo
	bne _seq_src_dec_lo
	ldx EXO_zp_src_hi
	bne _seq_src_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_src_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_src_bi
; -------------------------------------------------------------------
._seq_src_dec_hi
	dec EXO_zp_src_hi
	dec EXO_zp_src_bi
._seq_src_dec_lo
	dec EXO_zp_src_lo
; -------------------------------------------------------------------
	lda (EXO_zp_src_lo),y
; -------------------------------------------------------------------
._do_literal
	ldx EXO_zp_dest_lo
	bne _seq_dest_dec_lo
	ldx EXO_zp_dest_hi
	bne _seq_dest_dec_hi
; ------- handle buffer wrap problematics here ----------------------
	ldx #HI(EXO_buffer_len)
	stx EXO_zp_dest_hi
	ldx #HI(EXO_buffer_end)
	stx EXO_zp_dest_bi
; -------------------------------------------------------------------
._seq_dest_dec_hi
	dec EXO_zp_dest_hi
	dec EXO_zp_dest_bi
._seq_dest_dec_lo
	dec EXO_zp_dest_lo
; -------------------------------------------------------------------
	sta (EXO_zp_dest_lo),y
	clc
	rts
}

; -------------------------------------------------------------------
; two small static tables (6 bytes)
;
.tabl_bit
{
	EQUB 2,4,4
}
.tabl_off
{
	EQUB 48,32,16
}

; -------------------------------------------------------------------
; get x + 1 bits (1 byte)
;
._bit_get_bit1
	inx
; -------------------------------------------------------------------
; get bits (31 bytes)
;
; args:
;   x = number of bits to get
; returns:
;   a = #bits_lo
;   x = #0
;   c = 0
;   EXO_zp_bits_lo = #bits_lo
;   EXO_zp_bits_hi = #bits_hi
; notes:
;   y is untouched
;   other status bits are set to (a == #0)
; -------------------------------------------------------------------
._bit_get_bits
{
	lda #$00
	sta EXO_zp_bits_lo
	sta EXO_zp_bits_hi
	cpx #$01
	bcc _bit_bits_done
	lda EXO_zp_bitbuf
._bit_bits_next
	lsr a
	bne _bit_ok
	jsr get_crunched_byte
	ror a
._bit_ok
	rol EXO_zp_bits_lo
	rol EXO_zp_bits_hi
	dex
	bne _bit_bits_next
	sta EXO_zp_bitbuf
	lda EXO_zp_bits_lo
._bit_bits_done
	rts
}
; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

; -------------------------------------------------------------------
; this 156 byte table area may be relocated. It may also be clobbered
; by other data between decrunches.
; -------------------------------------------------------------------
.decrunch_table
.tabl_bi  SKIP 156
tabl_lo = decrunch_table + 52
tabl_hi = decrunch_table + 104

; -------------------------------------------------------------------
; end of decruncher
; -------------------------------------------------------------------

\ ******************************************************************
\ *	Stored data
\ ******************************************************************

.loading_table			; update NUM_vgm_files if this changes
EQUB LO(vgm_filename_1): EQUB HI(vgm_filename_1)
EQUB LO(vgm_filename_2): EQUB HI(vgm_filename_2)
EQUB LO(vgm_filename_3): EQUB HI(vgm_filename_3)
EQUB LO(vgm_filename_4): EQUB HI(vgm_filename_4)

.vgm_filename_1
EQUS "master", 13

.vgm_filename_2
EQUS "except", 13

.vgm_filename_3
EQUS "fluid", 13

.vgm_filename_4
EQUS "ice", 13

\\ Map character ASCII values to the byte offset into our MODE 7 font
\\ This is "cunning" but only works because the font has fewer than 256/6 (42) glyphs..

MAPCHAR 'A', 1
MAPCHAR 'B', 4
MAPCHAR 'C', 7
MAPCHAR 'D', 10
MAPCHAR 'E', 13
MAPCHAR 'F', 16
MAPCHAR 'G', 19
MAPCHAR 'H', 22
MAPCHAR 'I', 25
MAPCHAR 'J', 28
MAPCHAR 'K', 31
MAPCHAR 'L', 34
MAPCHAR 'M', 37

MAPCHAR 'a', 1
MAPCHAR 'b', 4
MAPCHAR 'c', 7
MAPCHAR 'd', 10
MAPCHAR 'e', 13
MAPCHAR 'f', 16
MAPCHAR 'g', 19
MAPCHAR 'h', 22
MAPCHAR 'i', 25
MAPCHAR 'j', 28
MAPCHAR 'k', 31
MAPCHAR 'l', 34
MAPCHAR 'm', 37

MAPCHAR 'N', 81
MAPCHAR 'O', 84
MAPCHAR 'P', 87
MAPCHAR 'Q', 90
MAPCHAR 'R', 93
MAPCHAR 'S', 96
MAPCHAR 'T', 99
MAPCHAR 'U', 102
MAPCHAR 'V', 105
MAPCHAR 'W', 108
MAPCHAR 'X', 111
MAPCHAR 'Y', 114
MAPCHAR 'Z', 117

MAPCHAR 'n', 81
MAPCHAR 'o', 84
MAPCHAR 'p', 87
MAPCHAR 'q', 90
MAPCHAR 'r', 93
MAPCHAR 's', 96
MAPCHAR 't', 99
MAPCHAR 'u', 102
MAPCHAR 'v', 105
MAPCHAR 'w', 108
MAPCHAR 'x', 111
MAPCHAR 'y', 114
MAPCHAR 'z', 117

MAPCHAR '0', 161
MAPCHAR '1', 164
MAPCHAR '2', 167
MAPCHAR '3', 170
MAPCHAR '4', 173
MAPCHAR '5', 176
MAPCHAR '6', 179
MAPCHAR '7', 182
MAPCHAR '8', 185
MAPCHAR '9', 188
MAPCHAR '?', 191
MAPCHAR '!', 194
MAPCHAR '.', 197

MAPCHAR ' ', 241

\\ Scrolltext messages stored as font glyph byte offsets

.demo_message
EQUS "BeebTracker scrolltext in the right place but now too fast! Needs to be one pixel scroll not one byte. 0123456789?!. ", 0

.load_message
EQUS "Loading... ", 0


\ ******************************************************************
\ *	Look up tables
\ ******************************************************************

\\ Start address of each row in MODE 7 - wasteful but helpful
.mode7_row_addr_LO
FOR n, 0, MODE7_char_height-1, 1
EQUB LO(MODE7_base_addr + n * MODE7_char_width)
NEXT

.mode7_row_addr_HI
FOR n, 0, MODE7_char_height-1, 1
EQUB HI(MODE7_base_addr + n * MODE7_char_width)
NEXT

\\ Lookup byte address for a given teletexel y coordinate - wasteful but fast
.mode7_texel_y_to_row_addr_LO
FOR n, 0, MODE7_texel_height-1, 1
	EQUB LO(MODE7_base_addr + ((n DIV 3) * MODE7_char_width) + 2)
NEXT

.mode7_texel_y_to_row_addr_HI
FOR n, 0, MODE7_texel_height-1, 1
	EQUB HI(MODE7_base_addr + ((n DIV 3) * MODE7_char_width) + 2)
NEXT

\\ Lookup bit mask for a given teletexel y coordinate - wasteful but fast
.mode7_texel_lookup_x_even
FOR n, 0, MODE7_texel_height-1, 1
	EQUB 1 << ((n % 3) * 2)
NEXT

.mode7_texel_lookup_x_odd
FOR n, 0, MODE7_texel_height-1, 1
	IF (n % 3) = 0
		EQUB 2
	ELIF (n % 3) = 1
		EQUB 8
	ELSE
		EQUB 64			; stupid teletext spec
	ENDIF
NEXT

\\ Note name lookup table, index using upper 8 bits of a 10-bit tone value. 256 bytes x 3.
\\ Not mega accurate, but fast, and good enough for a reasonably convincing visual 
ALIGN &100
.note_name_table_0 EQUS "AAAAGECAFEDCAGGFEDDCCCAGGGFFFEDDDDCCCCAAGGGGGFFFFFFEEEDDDDDDCCCCCCCCAAAAGGGGGGGGFFFFFFFFFFEEEEEDDDDDDDDDDDDCCCCCCCCCCCCCBBBBBBBAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGGGFFFFFFFFFFFFFFFFFFFEEEEEEEEEEEDDDDDDDDDDDDDDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBAA"
.note_name_table_1 EQUS "----#-#-#--#-#---#-#---#--#---##--##----###--###------###---####--------####----#####----------######------######--------------########--------########---------#########---------------------###########------------#############----------------------------##"
.note_name_table_2 EQUS "9999999888887777777777666666666666666655555555555555555555555555555544444444444444444444444444444444444444444444444444443333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333322222222222222222"

\\ 16 Arrangements of 5 teletext character bytes to render a vertical equalizer bar
.fx_table
EQUB 160, 160, 160, 160, 160
EQUB 160+80, 160, 160, 160, 160
EQUB 160+92, 160, 160, 160, 160
EQUB 160+95, 160, 160, 160, 160
EQUB 160+95, 160+80, 160, 160, 160
EQUB 160+95, 160+92, 160, 160, 160
EQUB 160+95, 160+95, 160, 160, 160
EQUB 160+95, 160+95, 160+80, 160, 160
EQUB 160+95, 160+95, 160+92, 160, 160
EQUB 160+95, 160+95, 160+95, 160, 160
EQUB 160+95, 160+95, 160+95, 160+80, 160
EQUB 160+95, 160+95, 160+95, 160+92, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160
EQUB 160+95, 160+95, 160+95, 160+95, 160+80
EQUB 160+95, 160+95, 160+95, 160+95, 160+92
EQUB 160+95, 160+95, 160+95, 160+95, 160+95
EQUB 160+95, 160+95, 160+95, 160+95, 160+95	; last row copied to enable fixed bar effect

\ ******************************************************************
\ *	MODE 7 screen data
\ ******************************************************************

.mode7_screen_data
INCBIN "screen3.mode7"

.mode7_font_data
INCBIN "font_5x5.mode7"

\ ******************************************************************
\ *	End address to be saved
\ ******************************************************************

.end


\ ******************************************************************
\ *	Space reserved for runtime buffers not preinitialised
\ ******************************************************************

\\ Exomiser unpack buffer (must be page aligned)
ALIGN &100
.EXO_buffer_start		SKIP EXO_buffer_len
.EXO_buffer_end

\\ Frequency array for vu-meter effect
.freq_array				SKIP FX_num_freqs

.osfile_params			SKIP 18

\ ******************************************************************
\ *	EXO VGM data file
\ * This must be compressed using the following flags:
\ * exomizer.exe raw -c -m 1024 <file.raw> -o <file.exo>
\ ******************************************************************

\\ TODO - load this at run-time!
ALIGN &100
.VGM_stream_data
.VGM_end_of_data


\ ******************************************************************
\ *	Save the code
\ ******************************************************************

SAVE "BeebTrk", start, end
PUTFILE "fluid_beeb_50.raw.exo", "fluid", 0
PUTFILE "ice_opt_beeb_50_raw.exo", "ice", 0
PUTFILE "exception_beeb.raw.exo", "except", 0
PUTFILE "master_beeb.raw.exo", "master", 0
PUTFILE "font_5x5.mode7", "font", &7C00
PUTFILE "menu_overlay.mode7", "menu", &7C00